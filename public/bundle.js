/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("'use strict';\n\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n\n  //variable store//\n  var vendorUrl = window.URL || window.webkitURL,\n      peer = void 0,\n      chattersClient = [],\n      chatterThisClient = void 0,\n      roomID = void 0,\n\n  //variables for video, peerCanvas, and context logic\n  peerVideo = void 0,\n      peerCanvas = void 0,\n      peerContext = void 0,\n      myCanvas = void 0,\n      myVideo = void 0,\n      //video canvas\n  myVidCtx = void 0,\n      myContext = void 0,\n      peerVidCtx = void 0,\n      peerVirtualVid = void 0,\n\n  //variables for filter logic\n  current = document.getElementById('filterDisp'),\n      button = document.getElementById('filter'),\n      filters = ['blur(5px)', 'brightness(0.4)', 'contrast(200%)', 'grayscale(100%)', 'hue-rotate(90deg)', 'invert(100%)', 'sepia(100%)', 'saturate(20)', ''],\n      i = 0,\n\n  //clear canvas\n  clearButton = document.getElementById('clear'),\n\n  //animation variables\n  staticButton = document.getElementById('static'),\n      bounceButton = document.getElementById('bounce'),\n      orbitButton = document.getElementById('orbit'),\n      currentAnimation = bounce,\n      temp = void 0,\n\n  //room buttons\n  joinButton = document.getElementById('join-button'),\n      randomButton = document.getElementById('random-button'),\n\n  //raf stands for requestAnimationFrame, enables drawing to occur\n  raf = void 0;\n\n  //image assignment, we can abstract this later\n  // let emoImg = new Image();\n  var currentImg = 'assets/smLoveTongue.png';\n\n  var socket = io();\n  //end variable store//\n\n  //vendor media objects//\n  navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n  //end vendor media objects//\n\n  //room selection\n  joinButton.addEventListener('click', function () {\n    roomID = document.getElementById('room-id-input').value;\n    socket.emit('joinRoom', JSON.stringify(roomID));\n    // socket.on('tryAgain', (payload) => alert('Try a different room!'))\n\n    socket.on('process', function (payload) {\n      console.log('in process', payload);\n      payload = JSON.parse(payload);\n      console.log(payload);\n      if (!payload) {\n        alert('Try a different room!');\n      } else {\n\n        document.getElementById('roomApp').classList.add('hidden');\n        document.getElementById('mainApp').classList.remove('hidden');\n        // }\n        // })\n        //begin streaming!//\n        navigator.getMedia({\n          video: true,\n          audio: false\n        }, function (stream) {\n\n          //make initiate event happen automatically when streaming begins\n          (function () {\n            socket.emit('initiate', JSON.stringify({\n              streamId: stream.id,\n              roomId: roomID\n            }));\n          })();\n\n          socket.on('readyConnect', function (payload) {\n            document.getElementById('connect').disabled = false;\n          });\n\n          socket.on('initiated', function (member) {\n            member = JSON.parse(member);\n\n            // document.getElementById('roomApp').classList.add('hidden');\n            // document.getElementById('mainApp').classList.remove('hidden');\n\n            //uses the stream from the local webcam and draws it on canvas//\n            var myVirtualVid = document.createElement('video');\n            myVirtualVid.src = window.URL.createObjectURL(stream);\n            myVirtualVid.play();\n\n            //draw local vid on canvas//\n            myVideo = document.getElementById('myVideo');\n            myVidCtx = myVideo.getContext('2d');\n\n            myVirtualVid.addEventListener('play', function () {\n              drawVideo(this, myVidCtx, myVideo.width, myVideo.height);\n            }, false);\n            //end//\n\n            //draw local overlay canvas//\n            myCanvas = document.getElementById('myCanvas');\n            myContext = myCanvas.getContext('2d');\n\n            //width and height should eventually be translated to exact coordination\n            //with incoming video stream\n            myCanvas.width = 500; //640;\n            myCanvas.height = 385; //480;\n\n            //draws blank canvas on top of video\n            myContext.rect(0, 0, myCanvas.width, myCanvas.height);\n            myContext.stroke();\n            //end//\n\n            //set room ID shared between clients\n            roomID = member.roomId;\n\n            if (chattersClient.filter(function (clientChatter) {\n              return clientChatter.id !== member.id;\n            }).length || !chattersClient.length) {\n              chattersClient.push(member);\n              chatterThisClient = member.id;\n            }\n\n            //instantiate peer object\n            peer = new SimplePeer({\n              initiator: member.initiator,\n              trickle: false,\n              stream: stream\n            });\n\n            peer.on('signal', function (data) {\n              document.getElementById('yourId').value = \"Connected!\";\n              var signalObj = JSON.stringify({\n                roomId: roomID,\n                signal: data\n              });\n\n              if (peer.initiator) {\n                socket.emit('initial', signalObj);\n              } else if (!peer.initiator) {\n                socket.emit('third', signalObj);\n              }\n            });\n\n            document.getElementById('connect').addEventListener('click', function () {\n              // if (!peer.initiator) {\n              socket.emit('second', JSON.stringify(roomID));\n              // }\n            });\n\n            socket.on('initialConnected', function () {\n              if (!peer.initiator) {\n                console.log('Initial connected good');\n              }\n            });\n\n            socket.on('secondPart2', function (initialClientSig) {\n              initialClientSig = JSON.parse(initialClientSig);\n              if (!peer.initiator) {\n                peer.signal(initialClientSig);\n              }\n            });\n\n            socket.on('thirdPart2', function (secondClientSig) {\n              secondClientSig = JSON.parse(secondClientSig);\n              if (peer.initiator) {\n                peer.signal(secondClientSig);\n              }\n            });\n\n            socket.on('updateChatters', function (chatter) {\n              chattersClient.splice(chattersClient.indexOf(chatter), 1);\n            });\n\n            peer.on('data', function (data) {\n\n              //parse data string to get the data object\n              var dataObj = JSON.parse(data);\n              //check data object for keys indicating if the type of data is a message\n              if (dataObj.message) {\n                //post message in the text content chat box spot\n                document.getElementById('messages').textContent += dataObj.message + '\\n';\n                //check data object for key indicating clicked the 'filter me!' button\n              } else if (dataObj.myFilter) {\n                //checks the value of the key to see if a filter needs to be added\n                if (dataObj.myFilter === 'yes') {\n                  //applies filter to video to reflect partner's video\n                  setVendorCss(peerVideo, dataObj.filterType);\n                  //checks value of key to see if filter needs to be removed\n                } else if (dataObj.myFilter === 'no') {\n                  //removes filter\n                  peerVideo.removeAttribute('style');\n                }\n\n                //check data object for key indicating user clicked the \"filter them\" button\n              } else if (dataObj.peerFilter) {\n                //checks key value to see if a filter needs to be added\n                if (dataObj.peerFilter === 'yes') {\n                  //applies filter\n                  setVendorCss(myVideo, dataObj.filterType);\n                  //checks key value to see if a filter needs to be removed\n                } else if (dataObj.peerFilter === 'no') {\n                  //removes filter\n                  myVideo.removeAttribute('style');\n                }\n              } else if (dataObj.emoji) {\n\n                //remote display bounce animation!\n                var emoImg = new Image();\n                emoImg.src = dataObj.currentImg;\n\n                temp = currentAnimation;\n                currentAnimation = eval('(' + dataObj.animation + ')');\n                currentAnimation(peerCanvas, peerContext, event, dataObj.position, emoImg);\n                currentAnimation = temp;\n              } else if (dataObj.peerEmoji) {\n\n                //local display bounce animation!\n                var _emoImg = new Image();\n                _emoImg.src = dataObj.currentImg;\n\n                temp = currentAnimation;\n                currentAnimation = eval('(' + dataObj.animation + ')');\n                currentAnimation(myCanvas, myContext, event, dataObj.position, _emoImg);\n                currentAnimation = temp;\n              }\n            });\n\n            //looks for click event on the send button//\n            document.getElementById('send').addEventListener('click', function () {\n\n              //creates a message object with a stringified object containing the local port and the message\n              var yourMessageObj = JSON.stringify({\n                message: \"pal:\" + \" \" + document.getElementById('yourMessage').value\n              });\n              //creates a variable with the same information to display on your side\n              //peer.localPort is a temporary way to identify peers, should be changed\n              var yourMessage = \"you:\" + \" \" + document.getElementById('yourMessage').value;\n              //post message in text context on your side\n              document.getElementById('messages').textContent += yourMessage + '\\n';\n              //send message object to the data channel\n              peer.send(yourMessageObj);\n            });\n            //end send click event//\n\n            //click event for the \"filter me\" button//\n            document.getElementById('myFilter').addEventListener('click', function () {\n              var filterDataObj = void 0;\n              //checks for filter and assigns key yes or no based on whether or not one needs to be applied\n              if (!myVideo.style.filter) {\n                //creates and stringify object to send to the data channel with instructions to apply filter\n                filterDataObj = JSON.stringify({\n                  myFilter: 'yes',\n                  filterType: current.innerHTML\n                });\n                //add filter on your side\n                setVendorCss(myVideo, current.innerHTML);\n              } else {\n                //create and stringify object to send to the data channel with instructions to remove filter\n                filterDataObj = JSON.stringify({\n                  myFilter: 'no'\n                });\n                myVideo.removeAttribute('style');\n              }\n              //send object to data channel\n              peer.send(filterDataObj);\n            });\n\n            //click event for the \"filter them\" button\n            document.getElementById('peerFilter').addEventListener('click', function () {\n\n              var filterDataObj = void 0;\n              //checks for filter and assigns key yes or no based on whether one needs to be applied\n              if (!peerVideo.style.filter) {\n                //creates and stringify object to send to the data channel with instructions to apply filter\n                filterDataObj = JSON.stringify({\n                  peerFilter: 'yes',\n                  filterType: current.innerHTML\n                });\n                //add filter on your side\n                setVendorCss(peerVideo, current.innerHTML);\n              } else {\n                //creates and stringify object to send to the data channel with instructions to remove filter\n                filterDataObj = JSON.stringify({\n                  peerFilter: 'no'\n                });\n                //remove filter on your side\n                peerVideo.removeAttribute('style');\n              }\n              //sends object to the data channel\n              peer.send(filterDataObj);\n            });\n            ///end filter them click event///\n\n            //tesing filters//\n            button.addEventListener('click', function () {\n              current.innerHTML = filters[i];\n              i++;\n              if (i >= filters.length) i = 0;\n            }, false);\n            //end of filter test//\n\n            myCanvas.addEventListener('click', function (event) {\n              //gets position based mouse click coordinates, restricted\n              //to canvas rectangle, see function logic in function store\n              var myPosition = getCursorPosition(myCanvas, event);\n\n              var emoImg = new Image();\n              emoImg.src = currentImg;\n\n              var myCanvasObj = JSON.stringify({\n                animation: currentAnimation.toString(),\n                emoji: 'yes',\n                currentImg: currentImg,\n                position: {\n                  x: myPosition.x,\n                  y: myPosition.y\n                }\n              });\n\n              //animation for local display and data transmission to peer\n              currentAnimation(myCanvas, myContext, event, myPosition, emoImg);\n              peer.send(myCanvasObj);\n            }, false);\n            //end of click listener logic//\n\n            // adding buttons to change active animations\n            staticButton.addEventListener('click', function (event) {\n              currentAnimation = staticPaste;\n            });\n\n            bounceButton.addEventListener('click', function (event) {\n              currentAnimation = bounce;\n            });\n\n            orbitButton.addEventListener('click', function (event) {\n              currentAnimation = orbit;\n            });\n\n            clearButton.addEventListener('click', function (event) {\n              cancelAnimationFrame(raf);\n              myContext.clearRect(0, 0, myCanvas.width, myCanvas.height);\n              peerContext.clearRect(0, 0, peerCanvas.width, peerCanvas.height);\n            });\n\n            //adding click handler for active emoji selection\n            var emojis = document.getElementsByClassName('emoji');\n\n            var _loop = function _loop(_i) {\n              emojis[_i].addEventListener('click', function (event) {\n                currentImg = emojis[_i].querySelectorAll('img')[0].getAttribute('src');\n              });\n            };\n\n            for (var _i = 0; _i < emojis.length; _i++) {\n              _loop(_i);\n            }\n\n            //peer stream event//\n            peer.on('stream', function (stream) {\n\n              // peerVideo = document.getElementById('peerVideo')\n              // peerVideo.src = vendorUrl.createObjectURL(stream);\n              // peerVideo.play();\n\n              //uses the stream from the remote webcam and draws it on canvas//\n              peerVirtualVid = document.createElement('video');\n              peerVirtualVid.src = vendorUrl.createObjectURL(stream);\n              peerVirtualVid.play();\n\n              peerVideo = document.getElementById('peerVideo');\n              peerVidCtx = peerVideo.getContext('2d');\n\n              peerVirtualVid.addEventListener('play', function () {\n                peerVideo.width = 500; //640;\n                peerVideo.height = 385; //460;\n                drawVideo(this, peerVidCtx, peerVideo.width, peerVideo.height);\n              }, false);\n              //end remote draw//\n\n              peerCanvas = document.getElementById('peerCanvas');\n              peerContext = peerCanvas.getContext('2d');\n\n              //width and height should eventually be translated to exact coordination\n              //with incoming video stream\n              peerCanvas.width = 500; //640;\n              peerCanvas.height = 385; //460;\n\n              //draws blank canvas on top of video, visibility may be unnecessary\n              peerContext.rect(0, 0, peerCanvas.width, peerCanvas.height);\n              peerContext.stroke();\n\n              //remote display animation this to data channel logic easy peasy\n              peerCanvas.addEventListener('click', function (event) {\n\n                //gets position based mouse click coordinates, restricted\n                //to canvas rectangle, see function logic in function store\n                var peerPosition = getCursorPosition(peerCanvas, event);\n\n                var emoImg = new Image();\n                emoImg.src = currentImg;\n\n                currentAnimation(peerCanvas, peerContext, event, peerPosition, emoImg);\n\n                var peerCanvasObj = JSON.stringify({\n                  animation: currentAnimation.toString(),\n                  peerEmoji: 'yes',\n                  currentImg: currentImg,\n                  position: {\n                    x: peerPosition.x,\n                    y: peerPosition.y\n                  }\n                });\n                peer.send(peerCanvasObj);\n              }, false);\n              //end of click listener logic//\n            });\n            ///end peer stream event///\n          }); //end of socket.on('initiated')\n\n        }, function (err) {\n          console.error(err);\n        });\n      } //end of boolean in socket 'process' event\n    }); //end of socket 'process' event\n  }); //end of 'join' event\n\n\n  //function store//\n\n  function bounce(cv, ctx, evt, pos, emoImg) {\n    var onload = emoImg.onload;\n\n    //this object keeps track of the movement, loads the images, and determines\n    //the velocity\n    var emoticon = {\n      x: pos.x,\n      y: pos.y,\n      vx: 5,\n      vy: 2,\n      onload: function onload() {\n        ctx.drawImage(emoImg, this.x - emoImg.width / 2, this.y - emoImg.height / 2);\n      }\n    };\n\n    //initial image load on canvas\n    emoticon.onload();\n    var callBack = function callBack() {\n      velocity(emoticon, ctx, cv, callBack, emoImg);\n    };\n\n    //start drawing movement\n    raf = window.requestAnimationFrame(callBack);\n  }\n\n  function staticPaste(cv, ctx, evt, pos, emoImg) {\n    var onload = emoImg.onload;\n\n    //this object keeps track of the movement, loads the images, and determines\n    //the velocity\n    var emoticon = {\n      x: pos.x,\n      y: pos.y,\n      vx: 5,\n      vy: 2,\n      onload: function onload() {\n        ctx.drawImage(emoImg, this.x - emoImg.width / 2, this.y - emoImg.height / 2);\n      }\n    };\n    //initial image load on canvas\n    emoticon.onload();\n  }\n\n  //orbit func//\n  function orbit(cv, ctx, evt, pos, emoImg) {\n    var onload = emoImg.onload;\n\n    //this object keeps track of the movement, loads the images, and determines\n    //the angular veloctiy. We're keeping track of frequency of refreshes to\n    //imcrement the degrees\n    var movement = .0349066;\n    var emoticon = {\n      x: pos.x,\n      y: pos.y,\n      r: 5,\n      rotateCount: 1,\n      wx: movement,\n      wy: movement,\n      onload: function onload() {\n        ctx.drawImage(emoImg, this.x - emoImg.width / 2, this.y - emoImg.height / 2);\n      }\n    };\n\n    //initial image load on canvas\n    emoticon.onload();\n\n    var callBack = function callBack() {\n      angularVelocity(emoticon, ctx, cv, callBack, emoImg);\n    };\n\n    //start drawing movement\n    raf = window.requestAnimationFrame(callBack);\n  }\n  //end orbit//\n\n  //paste object to canvas\n  function paste(video, context, width, height, x, y, source) {\n    context.drawImage(video, 0, 0, width, height);\n    baseImg = new Image();\n    baseImg.src = source; // needs to be path ie --> 'assets/weird.png';\n    baseImg.onload = function () {\n      context.drawImage(baseImg, x - baseImg.width / 2, y - baseImg.height / 2);\n      //setTimeout for pasted images//\n      // var time = window.setTimeout(function() {\n      // context.clearRect(x - baseImg.width / 2, y - baseImg.height / 2, baseImg.width, baseImg.height);\n      // }, 5000);\n    };\n  }\n  //end paste//\n\n  //gets cursor position upon mouse click that places\n  //an object or starts object movement\n  function getCursorPosition(canvas, event) {\n    var rect = canvas.getBoundingClientRect();\n    var x = event.clientX - rect.left;\n    var y = event.clientY - rect.top;\n    var pos = {\n      x: x,\n      y: y\n    };\n    return pos;\n  }\n  //end getCursorPosition//\n\n  //streamline vendor prefixing for css filtering\n  function setVendorCss(element, style) {\n    element.style.webkitFilter = style;\n    element.style.mozFilter = style;\n    element.style.filter = style;\n  }\n  //end setVendorCss //\n\n  //draws video on canvas\n  function drawVideo(v, c, w, h) {\n    if (v.paused || v.ended) return false;\n    c.drawImage(v, 0, 0, w, h);\n    setTimeout(drawVideo, 20, v, c, w, h);\n  }\n  //end drawVideo//\n\n  //canvas draw function for velocity motion\n  function velocity(obj, ctx, cv, cb, emoImg) {\n    ctx.clearRect(obj.x - emoImg.width / 2 - 5, obj.y - emoImg.height / 2 - 5, emoImg.width + 8, emoImg.height + 8);\n    obj.onload();\n    obj.x += obj.vx;\n    obj.y += obj.vy;\n    if (obj.y + obj.vy > cv.height || obj.y + obj.vy < 0) {\n      obj.vy = -obj.vy;\n    }\n    if (obj.x + obj.vx > cv.width || obj.x + obj.vx < 0) {\n      obj.vx = -obj.vx;\n    }\n    raf = window.requestAnimationFrame(cb);\n  }\n  //end velocity//\n\n  //angularVelocity func//\n  function angularVelocity(obj, ctx, cv, cb, emoImg) {\n    ctx.clearRect(obj.x - emoImg.width / 2 - 5, obj.y - emoImg.height / 2 - 5, emoImg.width + 10, emoImg.height + 10);\n    obj.onload();\n\n    obj.x += Math.sin(obj.wx * obj.rotateCount) * obj.r;\n    obj.y += Math.cos(obj.wy * obj.rotateCount) * obj.r;\n    obj.rotateCount++;\n\n    raf = window.requestAnimationFrame(cb);\n  }\n  //end angularVelocity//\n\n  //doesnt work yet, but would provide a way to erase drawn\n  //objects in circular fashion rather than rectangular\n  function cutCircle(context, x, y, radius) {\n    context.globalCompositeOperation = 'destination-out';\n    context.arc(x, y, radius, 0, Math.PI * 2, true);\n    context.fill();\n  }\n  //end cutCircle//\n\n  ///end of function store///\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9pbmRleC5qcz8xNjg3Il0sInNvdXJjZXNDb250ZW50IjpbImRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgLy92YXJpYWJsZSBzdG9yZS8vXG4gIGxldCB2ZW5kb3JVcmwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwsXG4gICAgcGVlcixcbiAgICBjaGF0dGVyc0NsaWVudCA9IFtdLFxuICAgIGNoYXR0ZXJUaGlzQ2xpZW50LFxuICAgIHJvb21JRCxcbiAgICAvL3ZhcmlhYmxlcyBmb3IgdmlkZW8sIHBlZXJDYW52YXMsIGFuZCBjb250ZXh0IGxvZ2ljXG4gICAgcGVlclZpZGVvLFxuICAgIHBlZXJDYW52YXMsXG4gICAgcGVlckNvbnRleHQsXG4gICAgbXlDYW52YXMsXG4gICAgbXlWaWRlbywgLy92aWRlbyBjYW52YXNcbiAgICBteVZpZEN0eCxcbiAgICBteUNvbnRleHQsXG4gICAgcGVlclZpZEN0eCxcbiAgICBwZWVyVmlydHVhbFZpZCxcbiAgICAvL3ZhcmlhYmxlcyBmb3IgZmlsdGVyIGxvZ2ljXG4gICAgY3VycmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXJEaXNwJyksXG4gICAgYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlcicpLFxuICAgIGZpbHRlcnMgPSBbJ2JsdXIoNXB4KScsICdicmlnaHRuZXNzKDAuNCknLCAnY29udHJhc3QoMjAwJSknLCAnZ3JheXNjYWxlKDEwMCUpJywgJ2h1ZS1yb3RhdGUoOTBkZWcpJywgJ2ludmVydCgxMDAlKScsICdzZXBpYSgxMDAlKScsICdzYXR1cmF0ZSgyMCknLCAnJ10sXG4gICAgaSA9IDAsXG4gICAgLy9jbGVhciBjYW52YXNcbiAgICBjbGVhckJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGVhcicpLFxuICAgIC8vYW5pbWF0aW9uIHZhcmlhYmxlc1xuICAgIHN0YXRpY0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0aWMnKSxcbiAgICBib3VuY2VCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm91bmNlJyksXG4gICAgb3JiaXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXQnKSxcbiAgICBjdXJyZW50QW5pbWF0aW9uID0gYm91bmNlLFxuICAgIHRlbXAsXG4gICAgLy9yb29tIGJ1dHRvbnNcbiAgICBqb2luQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pvaW4tYnV0dG9uJyksXG4gICAgcmFuZG9tQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmRvbS1idXR0b24nKSxcbiAgICAvL3JhZiBzdGFuZHMgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgZW5hYmxlcyBkcmF3aW5nIHRvIG9jY3VyXG4gICAgcmFmO1xuXG4gIC8vaW1hZ2UgYXNzaWdubWVudCwgd2UgY2FuIGFic3RyYWN0IHRoaXMgbGF0ZXJcbiAgLy8gbGV0IGVtb0ltZyA9IG5ldyBJbWFnZSgpO1xuICBsZXQgY3VycmVudEltZyA9ICdhc3NldHMvc21Mb3ZlVG9uZ3VlLnBuZyc7XG5cbiAgY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgLy9lbmQgdmFyaWFibGUgc3RvcmUvL1xuXG4gIC8vdmVuZG9yIG1lZGlhIG9iamVjdHMvL1xuICBuYXZpZ2F0b3IuZ2V0TWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG4gICAgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhO1xuICAvL2VuZCB2ZW5kb3IgbWVkaWEgb2JqZWN0cy8vXG5cbiAgLy9yb29tIHNlbGVjdGlvblxuICBqb2luQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICByb29tSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vbS1pZC1pbnB1dCcpLnZhbHVlO1xuICAgICAgc29ja2V0LmVtaXQoJ2pvaW5Sb29tJywgSlNPTi5zdHJpbmdpZnkocm9vbUlEKSk7XG4gICAgICAvLyBzb2NrZXQub24oJ3RyeUFnYWluJywgKHBheWxvYWQpID0+IGFsZXJ0KCdUcnkgYSBkaWZmZXJlbnQgcm9vbSEnKSlcblxuICAgICAgc29ja2V0Lm9uKCdwcm9jZXNzJywgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnaW4gcHJvY2VzcycsIHBheWxvYWQpXG4gICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICAgICAgY29uc29sZS5sb2cocGF5bG9hZClcbiAgICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdUcnkgYSBkaWZmZXJlbnQgcm9vbSEnKVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb29tQXBwJykuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkFwcCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAgIC8vYmVnaW4gc3RyZWFtaW5nIS8vXG4gICAgICAgICAgICBuYXZpZ2F0b3IuZ2V0TWVkaWEoe1xuICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihzdHJlYW0pIHtcblxuXG4gICAgICAgICAgICAgICAgLy9tYWtlIGluaXRpYXRlIGV2ZW50IGhhcHBlbiBhdXRvbWF0aWNhbGx5IHdoZW4gc3RyZWFtaW5nIGJlZ2luc1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdpbml0aWF0ZScsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9vbUlkOiByb29tSURcbiAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH0pKCk7XG5cblxuICAgICAgICAgICAgICAgIHNvY2tldC5vbigncmVhZHlDb25uZWN0JywgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25uZWN0JykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdpbml0aWF0ZWQnLCAobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IEpTT04ucGFyc2UobWVtYmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vbUFwcCcpLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkFwcCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlcyB0aGUgc3RyZWFtIGZyb20gdGhlIGxvY2FsIHdlYmNhbSBhbmQgZHJhd3MgaXQgb24gY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgbGV0IG15VmlydHVhbFZpZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgIG15VmlydHVhbFZpZC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBteVZpcnR1YWxWaWQucGxheSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBsb2NhbCB2aWQgb24gY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgbXlWaWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteVZpZGVvJylcbiAgICAgICAgICAgICAgICAgICAgbXlWaWRDdHggPSBteVZpZGVvLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbXlWaXJ0dWFsVmlkLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkcmF3VmlkZW8odGhpcywgbXlWaWRDdHgsIG15VmlkZW8ud2lkdGgsIG15VmlkZW8uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvL2VuZC8vXG5cbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGxvY2FsIG92ZXJsYXkgY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgbXlDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlDYW52YXMnKVxuICAgICAgICAgICAgICAgICAgICBteUNvbnRleHQgPSBteUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vd2lkdGggYW5kIGhlaWdodCBzaG91bGQgZXZlbnR1YWxseSBiZSB0cmFuc2xhdGVkIHRvIGV4YWN0IGNvb3JkaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAvL3dpdGggaW5jb21pbmcgdmlkZW8gc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgIG15Q2FudmFzLndpZHRoID0gNTAwOyAvLzY0MDtcbiAgICAgICAgICAgICAgICAgICAgbXlDYW52YXMuaGVpZ2h0ID0gMzg1OyAvLzQ4MDtcblxuICAgICAgICAgICAgICAgICAgICAvL2RyYXdzIGJsYW5rIGNhbnZhcyBvbiB0b3Agb2YgdmlkZW9cbiAgICAgICAgICAgICAgICAgICAgbXlDb250ZXh0LnJlY3QoMCwgMCwgbXlDYW52YXMud2lkdGgsIG15Q2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIG15Q29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9lbmQvL1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IHJvb20gSUQgc2hhcmVkIGJldHdlZW4gY2xpZW50c1xuICAgICAgICAgICAgICAgICAgICByb29tSUQgPSBtZW1iZXIucm9vbUlkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGF0dGVyc0NsaWVudC5maWx0ZXIoY2xpZW50Q2hhdHRlciA9PiBjbGllbnRDaGF0dGVyLmlkICE9PSBtZW1iZXIuaWQpLmxlbmd0aCB8fCAhY2hhdHRlcnNDbGllbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhdHRlcnNDbGllbnQucHVzaChtZW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXR0ZXJUaGlzQ2xpZW50ID0gbWVtYmVyLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pbnN0YW50aWF0ZSBwZWVyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwZWVyID0gbmV3IFNpbXBsZVBlZXIoe1xuICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRvcjogbWVtYmVyLmluaXRpYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICB0cmlja2xlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIHBlZXIub24oJ3NpZ25hbCcsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgneW91cklkJykudmFsdWUgPSBcIkNvbm5lY3RlZCFcIjtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgc2lnbmFsT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vbUlkOiByb29tSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVyLmluaXRpYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2luaXRpYWwnLCBzaWduYWxPYmopO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBlZXIuaW5pdGlhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZW1pdCgndGhpcmQnLCBzaWduYWxPYmopO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29ubmVjdCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFwZWVyLmluaXRpYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ3NlY29uZCcsIEpTT04uc3RyaW5naWZ5KHJvb21JRCkpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdpbml0aWFsQ29ubmVjdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZWVyLmluaXRpYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0luaXRpYWwgY29ubmVjdGVkIGdvb2QnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignc2Vjb25kUGFydDInLCAoaW5pdGlhbENsaWVudFNpZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDbGllbnRTaWcgPSBKU09OLnBhcnNlKGluaXRpYWxDbGllbnRTaWcpXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZWVyLmluaXRpYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVlci5zaWduYWwoaW5pdGlhbENsaWVudFNpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub24oJ3RoaXJkUGFydDInLCBmdW5jdGlvbihzZWNvbmRDbGllbnRTaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRDbGllbnRTaWcgPSBKU09OLnBhcnNlKHNlY29uZENsaWVudFNpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZXIuaW5pdGlhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyLnNpZ25hbChzZWNvbmRDbGllbnRTaWcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCd1cGRhdGVDaGF0dGVycycsIChjaGF0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhdHRlcnNDbGllbnQuc3BsaWNlKGNoYXR0ZXJzQ2xpZW50LmluZGV4T2YoY2hhdHRlciksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHBlZXIub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvL3BhcnNlIGRhdGEgc3RyaW5nIHRvIGdldCB0aGUgZGF0YSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YU9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBkYXRhIG9iamVjdCBmb3Iga2V5cyBpbmRpY2F0aW5nIGlmIHRoZSB0eXBlIG9mIGRhdGEgaXMgYSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFPYmoubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9wb3N0IG1lc3NhZ2UgaW4gdGhlIHRleHQgY29udGVudCBjaGF0IGJveCBzcG90XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZXMnKS50ZXh0Q29udGVudCArPSBkYXRhT2JqLm1lc3NhZ2UgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZGF0YSBvYmplY3QgZm9yIGtleSBpbmRpY2F0aW5nIGNsaWNrZWQgdGhlICdmaWx0ZXIgbWUhJyBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFPYmoubXlGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tzIHRoZSB2YWx1ZSBvZiB0aGUga2V5IHRvIHNlZSBpZiBhIGZpbHRlciBuZWVkcyB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFPYmoubXlGaWx0ZXIgPT09ICd5ZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbGllcyBmaWx0ZXIgdG8gdmlkZW8gdG8gcmVmbGVjdCBwYXJ0bmVyJ3MgdmlkZW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmVuZG9yQ3NzKHBlZXJWaWRlbywgZGF0YU9iai5maWx0ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVja3MgdmFsdWUgb2Yga2V5IHRvIHNlZSBpZiBmaWx0ZXIgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhT2JqLm15RmlsdGVyID09PSAnbm8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlcyBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVlclZpZGVvLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBkYXRhIG9iamVjdCBmb3Iga2V5IGluZGljYXRpbmcgdXNlciBjbGlja2VkIHRoZSBcImZpbHRlciB0aGVtXCIgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhT2JqLnBlZXJGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tzIGtleSB2YWx1ZSB0byBzZWUgaWYgYSBmaWx0ZXIgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhT2JqLnBlZXJGaWx0ZXIgPT09ICd5ZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbGllcyBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmVuZG9yQ3NzKG15VmlkZW8sIGRhdGFPYmouZmlsdGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tzIGtleSB2YWx1ZSB0byBzZWUgaWYgYSBmaWx0ZXIgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhT2JqLnBlZXJGaWx0ZXIgPT09ICdubycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmVzIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICBteVZpZGVvLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFPYmouZW1vamkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdGUgZGlzcGxheSBib3VuY2UgYW5pbWF0aW9uIVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVtb0ltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1vSW1nLnNyYyA9IGRhdGFPYmouY3VycmVudEltZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGN1cnJlbnRBbmltYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gZXZhbCgnKCcgKyBkYXRhT2JqLmFuaW1hdGlvbiArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uKHBlZXJDYW52YXMsIHBlZXJDb250ZXh0LCBldmVudCwgZGF0YU9iai5wb3NpdGlvbiwgZW1vSW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhT2JqLnBlZXJFbW9qaSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvY2FsIGRpc3BsYXkgYm91bmNlIGFuaW1hdGlvbiFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbW9JbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtb0ltZy5zcmMgPSBkYXRhT2JqLmN1cnJlbnRJbWc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjdXJyZW50QW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGV2YWwoJygnICsgZGF0YU9iai5hbmltYXRpb24gKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbihteUNhbnZhcywgbXlDb250ZXh0LCBldmVudCwgZGF0YU9iai5wb3NpdGlvbiwgZW1vSW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24gPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb29rcyBmb3IgY2xpY2sgZXZlbnQgb24gdGhlIHNlbmQgYnV0dG9uLy9cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbmQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlcyBhIG1lc3NhZ2Ugb2JqZWN0IHdpdGggYSBzdHJpbmdpZmllZCBvYmplY3QgY29udGFpbmluZyB0aGUgbG9jYWwgcG9ydCBhbmQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB5b3VyTWVzc2FnZU9iaiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJwYWw6XCIgKyBcIiBcIiArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd5b3VyTWVzc2FnZScpLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlcyBhIHZhcmlhYmxlIHdpdGggdGhlIHNhbWUgaW5mb3JtYXRpb24gdG8gZGlzcGxheSBvbiB5b3VyIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcGVlci5sb2NhbFBvcnQgaXMgYSB0ZW1wb3Jhcnkgd2F5IHRvIGlkZW50aWZ5IHBlZXJzLCBzaG91bGQgYmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHlvdXJNZXNzYWdlID0gXCJ5b3U6XCIgKyBcIiBcIiArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd5b3VyTWVzc2FnZScpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9wb3N0IG1lc3NhZ2UgaW4gdGV4dCBjb250ZXh0IG9uIHlvdXIgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lc3NhZ2VzJykudGV4dENvbnRlbnQgKz0geW91ck1lc3NhZ2UgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VuZCBtZXNzYWdlIG9iamVjdCB0byB0aGUgZGF0YSBjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyLnNlbmQoeW91ck1lc3NhZ2VPYmopO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLy9lbmQgc2VuZCBjbGljayBldmVudC8vXG5cbiAgICAgICAgICAgICAgICAgICAgLy9jbGljayBldmVudCBmb3IgdGhlIFwiZmlsdGVyIG1lXCIgYnV0dG9uLy9cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215RmlsdGVyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyRGF0YU9iajtcbiAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcyBmb3IgZmlsdGVyIGFuZCBhc3NpZ25zIGtleSB5ZXMgb3Igbm8gYmFzZWQgb24gd2hldGhlciBvciBub3Qgb25lIG5lZWRzIHRvIGJlIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIW15VmlkZW8uc3R5bGUuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZXMgYW5kIHN0cmluZ2lmeSBvYmplY3QgdG8gc2VuZCB0byB0aGUgZGF0YSBjaGFubmVsIHdpdGggaW5zdHJ1Y3Rpb25zIHRvIGFwcGx5IGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRGF0YU9iaiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXlGaWx0ZXI6ICd5ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBjdXJyZW50LmlubmVySFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCBmaWx0ZXIgb24geW91ciBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWZW5kb3JDc3MobXlWaWRlbywgY3VycmVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBhbmQgc3RyaW5naWZ5IG9iamVjdCB0byBzZW5kIHRvIHRoZSBkYXRhIGNoYW5uZWwgd2l0aCBpbnN0cnVjdGlvbnMgdG8gcmVtb3ZlIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRGF0YU9iaiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXlGaWx0ZXI6ICdubydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlWaWRlby5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vc2VuZCBvYmplY3QgdG8gZGF0YSBjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlci5zZW5kKGZpbHRlckRhdGFPYmopO1xuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY2xpY2sgZXZlbnQgZm9yIHRoZSBcImZpbHRlciB0aGVtXCIgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZWVyRmlsdGVyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJEYXRhT2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVja3MgZm9yIGZpbHRlciBhbmQgYXNzaWducyBrZXkgeWVzIG9yIG5vIGJhc2VkIG9uIHdoZXRoZXIgb25lIG5lZWRzIHRvIGJlIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVlclZpZGVvLnN0eWxlLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZXMgYW5kIHN0cmluZ2lmeSBvYmplY3QgdG8gc2VuZCB0byB0aGUgZGF0YSBjaGFubmVsIHdpdGggaW5zdHJ1Y3Rpb25zIHRvIGFwcGx5IGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJGaWx0ZXI6ICd5ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclR5cGU6IGN1cnJlbnQuaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCBmaWx0ZXIgb24geW91ciBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZlbmRvckNzcyhwZWVyVmlkZW8sIGN1cnJlbnQuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlcyBhbmQgc3RyaW5naWZ5IG9iamVjdCB0byBzZW5kIHRvIHRoZSBkYXRhIGNoYW5uZWwgd2l0aCBpbnN0cnVjdGlvbnMgdG8gcmVtb3ZlIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJGaWx0ZXI6ICdubydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGZpbHRlciBvbiB5b3VyIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVlclZpZGVvLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VuZHMgb2JqZWN0IHRvIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXIuc2VuZChmaWx0ZXJEYXRhT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC8vL2VuZCBmaWx0ZXIgdGhlbSBjbGljayBldmVudC8vL1xuXG4gICAgICAgICAgICAgICAgICAgIC8vdGVzaW5nIGZpbHRlcnMvL1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmlubmVySFRNTCA9IGZpbHRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IGZpbHRlcnMubGVuZ3RoKSBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvL2VuZCBvZiBmaWx0ZXIgdGVzdC8vXG5cbiAgICAgICAgICAgICAgICAgICAgbXlDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXRzIHBvc2l0aW9uIGJhc2VkIG1vdXNlIGNsaWNrIGNvb3JkaW5hdGVzLCByZXN0cmljdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvIGNhbnZhcyByZWN0YW5nbGUsIHNlZSBmdW5jdGlvbiBsb2dpYyBpbiBmdW5jdGlvbiBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG15UG9zaXRpb24gPSBnZXRDdXJzb3JQb3NpdGlvbihteUNhbnZhcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW1vSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbW9JbWcuc3JjID0gY3VycmVudEltZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG15Q2FudmFzT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGN1cnJlbnRBbmltYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW1vamk6ICd5ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW1nOiBjdXJyZW50SW1nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IG15UG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBteVBvc2l0aW9uLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYW5pbWF0aW9uIGZvciBsb2NhbCBkaXNwbGF5IGFuZCBkYXRhIHRyYW5zbWlzc2lvbiB0byBwZWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uKG15Q2FudmFzLCBteUNvbnRleHQsIGV2ZW50LCBteVBvc2l0aW9uLCBlbW9JbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVlci5zZW5kKG15Q2FudmFzT2JqKTtcblxuICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgIC8vZW5kIG9mIGNsaWNrIGxpc3RlbmVyIGxvZ2ljLy9cblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgYnV0dG9ucyB0byBjaGFuZ2UgYWN0aXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gc3RhdGljUGFzdGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGJvdW5jZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGJvdW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3JiaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24gPSBvcmJpdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgICAgICAgICAgICAgICAgICAgbXlDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBteUNhbnZhcy53aWR0aCwgbXlDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgcGVlckNhbnZhcy53aWR0aCwgcGVlckNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkaW5nIGNsaWNrIGhhbmRsZXIgZm9yIGFjdGl2ZSBlbW9qaSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1vamlzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZW1vamknKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbW9qaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgIGVtb2ppc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW1nID0gZW1vamlzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpWzBdLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vcGVlciBzdHJlYW0gZXZlbnQvL1xuICAgICAgICAgICAgICAgICAgICBwZWVyLm9uKCdzdHJlYW0nLCBmdW5jdGlvbihzdHJlYW0pIHtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBlZXJWaWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZWVyVmlkZW8nKVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBlZXJWaWRlby5zcmMgPSB2ZW5kb3JVcmwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gcGVlclZpZGVvLnBsYXkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vdXNlcyB0aGUgc3RyZWFtIGZyb20gdGhlIHJlbW90ZSB3ZWJjYW0gYW5kIGRyYXdzIGl0IG9uIGNhbnZhcy8vXG4gICAgICAgICAgICAgICAgICAgICAgcGVlclZpcnR1YWxWaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaXJ0dWFsVmlkLnNyYyA9IHZlbmRvclVybC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlydHVhbFZpZC5wbGF5KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGVlclZpZGVvJylcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlkQ3R4ID0gcGVlclZpZGVvLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlydHVhbFZpZC5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlkZW8ud2lkdGggPSA1MDA7IC8vNjQwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVlclZpZGVvLmhlaWdodCA9IDM4NTsgLy80NjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VmlkZW8odGhpcywgcGVlclZpZEN0eCwgcGVlclZpZGVvLndpZHRoLCBwZWVyVmlkZW8uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgLy9lbmQgcmVtb3RlIGRyYXcvL1xuXG4gICAgICAgICAgICAgICAgICAgICAgcGVlckNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZWVyQ2FudmFzJylcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQ29udGV4dCA9IHBlZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vd2lkdGggYW5kIGhlaWdodCBzaG91bGQgZXZlbnR1YWxseSBiZSB0cmFuc2xhdGVkIHRvIGV4YWN0IGNvb3JkaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAgIC8vd2l0aCBpbmNvbWluZyB2aWRlbyBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQ2FudmFzLndpZHRoID0gNTAwOyAvLzY0MDtcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQ2FudmFzLmhlaWdodCA9IDM4NTsgLy80NjA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvL2RyYXdzIGJsYW5rIGNhbnZhcyBvbiB0b3Agb2YgdmlkZW8sIHZpc2liaWxpdHkgbWF5IGJlIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgcGVlckNvbnRleHQucmVjdCgwLCAwLCBwZWVyQ2FudmFzLndpZHRoLCBwZWVyQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVlckNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvL3JlbW90ZSBkaXNwbGF5IGFuaW1hdGlvbiB0aGlzIHRvIGRhdGEgY2hhbm5lbCBsb2dpYyBlYXN5IHBlYXN5XG4gICAgICAgICAgICAgICAgICAgICAgcGVlckNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXRzIHBvc2l0aW9uIGJhc2VkIG1vdXNlIGNsaWNrIGNvb3JkaW5hdGVzLCByZXN0cmljdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vdG8gY2FudmFzIHJlY3RhbmdsZSwgc2VlIGZ1bmN0aW9uIGxvZ2ljIGluIGZ1bmN0aW9uIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwZWVyUG9zaXRpb24gPSBnZXRDdXJzb3JQb3NpdGlvbihwZWVyQ2FudmFzLCBldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVtb0ltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlbW9JbWcuc3JjID0gY3VycmVudEltZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uKHBlZXJDYW52YXMsIHBlZXJDb250ZXh0LCBldmVudCwgcGVlclBvc2l0aW9uLCBlbW9JbWcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwZWVyQ2FudmFzT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogY3VycmVudEFuaW1hdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJFbW9qaTogJ3llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEltZzogY3VycmVudEltZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcGVlclBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwZWVyUG9zaXRpb24ueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZXIuc2VuZChwZWVyQ2FudmFzT2JqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2VuZCBvZiBjbGljayBsaXN0ZW5lciBsb2dpYy8vXG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vL2VuZCBwZWVyIHN0cmVhbSBldmVudC8vL1xuICAgICAgICAgICAgICAgICAgfSkgLy9lbmQgb2Ygc29ja2V0Lm9uKCdpbml0aWF0ZWQnKVxuXG5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0gLy9lbmQgb2YgYm9vbGVhbiBpbiBzb2NrZXQgJ3Byb2Nlc3MnIGV2ZW50XG5cbiAgICAgICAgfSkgLy9lbmQgb2Ygc29ja2V0ICdwcm9jZXNzJyBldmVudFxuXG4gICAgfSkgLy9lbmQgb2YgJ2pvaW4nIGV2ZW50XG5cblxuICAvL2Z1bmN0aW9uIHN0b3JlLy9cblxuICBmdW5jdGlvbiBib3VuY2UoY3YsIGN0eCwgZXZ0LCBwb3MsIGVtb0ltZykge1xuICAgIGxldCBvbmxvYWQgPSBlbW9JbWcub25sb2FkO1xuXG4gICAgLy90aGlzIG9iamVjdCBrZWVwcyB0cmFjayBvZiB0aGUgbW92ZW1lbnQsIGxvYWRzIHRoZSBpbWFnZXMsIGFuZCBkZXRlcm1pbmVzXG4gICAgLy90aGUgdmVsb2NpdHlcbiAgICBsZXQgZW1vdGljb24gPSB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55LFxuICAgICAgdng6IDUsXG4gICAgICB2eTogMixcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoZW1vSW1nLCB0aGlzLnggLSBlbW9JbWcud2lkdGggLyAyLCB0aGlzLnkgLSBlbW9JbWcuaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vaW5pdGlhbCBpbWFnZSBsb2FkIG9uIGNhbnZhc1xuICAgIGVtb3RpY29uLm9ubG9hZCgpO1xuICAgIGxldCBjYWxsQmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmVsb2NpdHkoZW1vdGljb24sIGN0eCwgY3YsIGNhbGxCYWNrLCBlbW9JbWcpO1xuICAgIH1cblxuICAgIC8vc3RhcnQgZHJhd2luZyBtb3ZlbWVudFxuICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbEJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGljUGFzdGUoY3YsIGN0eCwgZXZ0LCBwb3MsIGVtb0ltZykge1xuICAgIGxldCBvbmxvYWQgPSBlbW9JbWcub25sb2FkO1xuXG4gICAgLy90aGlzIG9iamVjdCBrZWVwcyB0cmFjayBvZiB0aGUgbW92ZW1lbnQsIGxvYWRzIHRoZSBpbWFnZXMsIGFuZCBkZXRlcm1pbmVzXG4gICAgLy90aGUgdmVsb2NpdHlcbiAgICBsZXQgZW1vdGljb24gPSB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55LFxuICAgICAgdng6IDUsXG4gICAgICB2eTogMixcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoZW1vSW1nLCB0aGlzLnggLSBlbW9JbWcud2lkdGggLyAyLCB0aGlzLnkgLSBlbW9JbWcuaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfTtcbiAgICAvL2luaXRpYWwgaW1hZ2UgbG9hZCBvbiBjYW52YXNcbiAgICBlbW90aWNvbi5vbmxvYWQoKTtcbiAgfVxuXG4gIC8vb3JiaXQgZnVuYy8vXG4gIGZ1bmN0aW9uIG9yYml0KGN2LCBjdHgsIGV2dCwgcG9zLCBlbW9JbWcpIHtcbiAgICBsZXQgb25sb2FkID0gZW1vSW1nLm9ubG9hZDtcblxuICAgIC8vdGhpcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgdGhlIG1vdmVtZW50LCBsb2FkcyB0aGUgaW1hZ2VzLCBhbmQgZGV0ZXJtaW5lc1xuICAgIC8vdGhlIGFuZ3VsYXIgdmVsb2N0aXkuIFdlJ3JlIGtlZXBpbmcgdHJhY2sgb2YgZnJlcXVlbmN5IG9mIHJlZnJlc2hlcyB0b1xuICAgIC8vaW1jcmVtZW50IHRoZSBkZWdyZWVzXG4gICAgbGV0IG1vdmVtZW50ID0gLjAzNDkwNjY7XG4gICAgbGV0IGVtb3RpY29uID0ge1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueSxcbiAgICAgIHI6IDUsXG4gICAgICByb3RhdGVDb3VudDogMSxcbiAgICAgIHd4OiBtb3ZlbWVudCxcbiAgICAgIHd5OiBtb3ZlbWVudCxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoZW1vSW1nLCB0aGlzLnggLSBlbW9JbWcud2lkdGggLyAyLCB0aGlzLnkgLSBlbW9JbWcuaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vaW5pdGlhbCBpbWFnZSBsb2FkIG9uIGNhbnZhc1xuICAgIGVtb3RpY29uLm9ubG9hZCgpO1xuXG4gICAgbGV0IGNhbGxCYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBhbmd1bGFyVmVsb2NpdHkoZW1vdGljb24sIGN0eCwgY3YsIGNhbGxCYWNrLCBlbW9JbWcpO1xuICAgIH1cblxuICAgIC8vc3RhcnQgZHJhd2luZyBtb3ZlbWVudFxuICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbEJhY2spO1xuICB9XG4gIC8vZW5kIG9yYml0Ly9cblxuICAvL3Bhc3RlIG9iamVjdCB0byBjYW52YXNcbiAgZnVuY3Rpb24gcGFzdGUodmlkZW8sIGNvbnRleHQsIHdpZHRoLCBoZWlnaHQsIHgsIHksIHNvdXJjZSkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBiYXNlSW1nID0gbmV3IEltYWdlKCk7XG4gICAgYmFzZUltZy5zcmMgPSBzb3VyY2U7IC8vIG5lZWRzIHRvIGJlIHBhdGggaWUgLS0+ICdhc3NldHMvd2VpcmQucG5nJztcbiAgICBiYXNlSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoYmFzZUltZywgeCAtIGJhc2VJbWcud2lkdGggLyAyLCB5IC0gYmFzZUltZy5oZWlnaHQgLyAyKTtcbiAgICAgIC8vc2V0VGltZW91dCBmb3IgcGFzdGVkIGltYWdlcy8vXG4gICAgICAvLyB2YXIgdGltZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29udGV4dC5jbGVhclJlY3QoeCAtIGJhc2VJbWcud2lkdGggLyAyLCB5IC0gYmFzZUltZy5oZWlnaHQgLyAyLCBiYXNlSW1nLndpZHRoLCBiYXNlSW1nLmhlaWdodCk7XG4gICAgICAvLyB9LCA1MDAwKTtcbiAgICB9XG4gIH1cbiAgLy9lbmQgcGFzdGUvL1xuXG4gIC8vZ2V0cyBjdXJzb3IgcG9zaXRpb24gdXBvbiBtb3VzZSBjbGljayB0aGF0IHBsYWNlc1xuICAvL2FuIG9iamVjdCBvciBzdGFydHMgb2JqZWN0IG1vdmVtZW50XG4gIGZ1bmN0aW9uIGdldEN1cnNvclBvc2l0aW9uKGNhbnZhcywgZXZlbnQpIHtcbiAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgbGV0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgbGV0IHBvcyA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIC8vZW5kIGdldEN1cnNvclBvc2l0aW9uLy9cblxuICAvL3N0cmVhbWxpbmUgdmVuZG9yIHByZWZpeGluZyBmb3IgY3NzIGZpbHRlcmluZ1xuICBmdW5jdGlvbiBzZXRWZW5kb3JDc3MoZWxlbWVudCwgc3R5bGUpIHtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdEZpbHRlciA9IHN0eWxlO1xuICAgIGVsZW1lbnQuc3R5bGUubW96RmlsdGVyID0gc3R5bGU7XG4gICAgZWxlbWVudC5zdHlsZS5maWx0ZXIgPSBzdHlsZTtcbiAgfVxuICAvL2VuZCBzZXRWZW5kb3JDc3MgLy9cblxuICAvL2RyYXdzIHZpZGVvIG9uIGNhbnZhc1xuICBmdW5jdGlvbiBkcmF3VmlkZW8odiwgYywgdywgaCkge1xuICAgIGlmICh2LnBhdXNlZCB8fCB2LmVuZGVkKSByZXR1cm4gZmFsc2U7XG4gICAgYy5kcmF3SW1hZ2UodiwgMCwgMCwgdywgaCk7XG4gICAgc2V0VGltZW91dChkcmF3VmlkZW8sIDIwLCB2LCBjLCB3LCBoKTtcbiAgfVxuICAvL2VuZCBkcmF3VmlkZW8vL1xuXG4gIC8vY2FudmFzIGRyYXcgZnVuY3Rpb24gZm9yIHZlbG9jaXR5IG1vdGlvblxuICBmdW5jdGlvbiB2ZWxvY2l0eShvYmosIGN0eCwgY3YsIGNiLCBlbW9JbWcpIHtcbiAgICBjdHguY2xlYXJSZWN0KG9iai54IC0gZW1vSW1nLndpZHRoIC8gMiAtIDUsIG9iai55IC0gZW1vSW1nLmhlaWdodCAvIDIgLSA1LCBlbW9JbWcud2lkdGggKyA4LCBlbW9JbWcuaGVpZ2h0ICsgOCk7XG4gICAgb2JqLm9ubG9hZCgpO1xuICAgIG9iai54ICs9IG9iai52eDtcbiAgICBvYmoueSArPSBvYmoudnk7XG4gICAgaWYgKG9iai55ICsgb2JqLnZ5ID4gY3YuaGVpZ2h0IHx8IG9iai55ICsgb2JqLnZ5IDwgMCkge1xuICAgICAgb2JqLnZ5ID0gLW9iai52eTtcbiAgICB9XG4gICAgaWYgKG9iai54ICsgb2JqLnZ4ID4gY3Yud2lkdGggfHwgb2JqLnggKyBvYmoudnggPCAwKSB7XG4gICAgICBvYmoudnggPSAtb2JqLnZ4O1xuICAgIH1cbiAgICByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfVxuICAvL2VuZCB2ZWxvY2l0eS8vXG5cbiAgLy9hbmd1bGFyVmVsb2NpdHkgZnVuYy8vXG4gIGZ1bmN0aW9uIGFuZ3VsYXJWZWxvY2l0eShvYmosIGN0eCwgY3YsIGNiLCBlbW9JbWcpIHtcbiAgICBjdHguY2xlYXJSZWN0KG9iai54IC0gZW1vSW1nLndpZHRoIC8gMiAtIDUsIG9iai55IC0gZW1vSW1nLmhlaWdodCAvIDIgLSA1LCBlbW9JbWcud2lkdGggKyAxMCwgZW1vSW1nLmhlaWdodCArIDEwKTtcbiAgICBvYmoub25sb2FkKCk7XG5cbiAgICBvYmoueCArPSBNYXRoLnNpbihvYmoud3ggKiBvYmoucm90YXRlQ291bnQpICogb2JqLnI7XG4gICAgb2JqLnkgKz0gTWF0aC5jb3Mob2JqLnd5ICogb2JqLnJvdGF0ZUNvdW50KSAqIG9iai5yO1xuICAgIG9iai5yb3RhdGVDb3VudCsrO1xuXG4gICAgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH1cbiAgLy9lbmQgYW5ndWxhclZlbG9jaXR5Ly9cblxuICAvL2RvZXNudCB3b3JrIHlldCwgYnV0IHdvdWxkIHByb3ZpZGUgYSB3YXkgdG8gZXJhc2UgZHJhd25cbiAgLy9vYmplY3RzIGluIGNpcmN1bGFyIGZhc2hpb24gcmF0aGVyIHRoYW4gcmVjdGFuZ3VsYXJcbiAgZnVuY3Rpb24gY3V0Q2lyY2xlKGNvbnRleHQsIHgsIHksIHJhZGl1cykge1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCdcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuICAvL2VuZCBjdXRDaXJjbGUvL1xuXG4gIC8vL2VuZCBvZiBmdW5jdGlvbiBzdG9yZS8vL1xuXG59KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIGluZGV4LmpzXG4gKiovIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV0E7QUFYQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXZCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBMkJBO0FBQ0E7QUE3QkE7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxSQTtBQW1SQTtBQUNBO0FBQ0E7QUFyUkE7QUFDQTtBQWlSQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);