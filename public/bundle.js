/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("'use strict';\n\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n\n  //variable store//\n  var vendorUrl = window.URL || window.webkitURL,\n      peer = void 0,\n      chattersClient = [],\n      chatterThisClient = void 0,\n      roomID = void 0,\n\n  //variables for video, peerCanvas, and context logic\n  peerVideo = void 0,\n      peerCanvas = void 0,\n      peerContext = void 0,\n      myCanvas = void 0,\n      myVideo = void 0,\n      //video canvas\n  myVidCtx = void 0,\n      myContext = void 0,\n      peerVidCtx = void 0,\n      peerVirtualVid = void 0,\n\n  //variables for filter logic\n  current = document.getElementById('filterDisp'),\n      button = document.getElementById('filter'),\n      filters = ['blur(5px)', 'brightness(0.4)', 'contrast(200%)', 'grayscale(100%)', 'hue-rotate(90deg)', 'invert(100%)', 'sepia(100%)', 'saturate(20)', ''],\n      i = 0,\n\n  //clear canvas\n  clearButton = document.getElementById('clear'),\n\n  //animation variables\n  staticButton = document.getElementById('static'),\n      bounceButton = document.getElementById('bounce'),\n      orbitButton = document.getElementById('orbit'),\n      currentAnimation = bounce,\n      temp = void 0,\n\n  //room buttons\n  joinButton = document.getElementById('join-button'),\n      randomButton = document.getElementById('random-button'),\n\n  //raf stands for requestAnimationFrame, enables drawing to occur\n  raf = void 0;\n\n  //image assignment, we can abstract this later\n  // let emoImg = new Image();\n  var currentImg = 'assets/smLoveTongue.png';\n\n  var socket = io();\n  //end variable store//\n\n  //vendor media objects//\n  navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n  //end vendor media objects//\n\n  //room selection\n  joinButton.addEventListener('click', function () {\n    roomID = document.getElementById('room-id-input').value;\n    socket.emit('joinRoom', JSON.stringify(roomID));\n    // socket.on('tryAgain', (payload) => alert('Try a different room!'))\n\n    socket.on('process', function (payload) {\n      console.log('in process', payload);\n      payload = JSON.parse(payload);\n      console.log(payload);\n      if (!payload) {\n        alert('Try a different room!');\n      } else {\n\n        document.getElementById('roomApp').classList.add('hidden');\n        document.getElementById('mainApp').classList.remove('hidden');\n        // }\n        // })\n        //begin streaming!//\n        navigator.getMedia({\n          video: true,\n          audio: false\n        }, function (stream) {\n\n          //make initiate event happen automatically when streaming begins\n          (function () {\n            socket.emit('initiate', JSON.stringify({\n              streamId: stream.id,\n              roomId: roomID\n            }));\n          })();\n\n          socket.on('readyConnect', function (payload) {\n            document.getElementById('connect').disabled = false;\n          });\n\n          socket.on('initiated', function (member) {\n            member = JSON.parse(member);\n\n            // document.getElementById('roomApp').classList.add('hidden');\n            // document.getElementById('mainApp').classList.remove('hidden');\n\n            //uses the stream from the local webcam and draws it on canvas//\n            var myVirtualVid = document.createElement('video');\n            myVirtualVid.src = window.URL.createObjectURL(stream);\n            myVirtualVid.play();\n\n            //draw local vid on canvas//\n            myVideo = document.getElementById('myVideo');\n            myVidCtx = myVideo.getContext('2d');\n\n            myVirtualVid.addEventListener('play', function () {\n              drawVideo(this, myVidCtx, myVideo.width, myVideo.height);\n            }, false);\n            //end//\n\n            //draw local overlay canvas//\n            myCanvas = document.getElementById('myCanvas');\n            myContext = myCanvas.getContext('2d');\n\n            //width and height should eventually be translated to exact coordination\n            //with incoming video stream\n            myCanvas.width = 640;\n            myCanvas.height = 480;\n\n            //draws blank canvas on top of video\n            myContext.rect(0, 0, myCanvas.width, myCanvas.height);\n            myContext.stroke();\n            //end//\n\n            //set room ID shared between clients\n            roomID = member.roomId;\n\n            if (chattersClient.filter(function (clientChatter) {\n              return clientChatter.id !== member.id;\n            }).length || !chattersClient.length) {\n              chattersClient.push(member);\n              chatterThisClient = member.id;\n            }\n\n            //instantiate peer object\n            peer = new SimplePeer({\n              initiator: member.initiator,\n              trickle: false,\n              stream: stream\n            });\n\n            peer.on('signal', function (data) {\n              document.getElementById('yourId').value = \"Connected!\";\n              var signalObj = JSON.stringify({\n                roomId: roomID,\n                signal: data\n              });\n\n              if (peer.initiator) {\n                socket.emit('initial', signalObj);\n              } else if (!peer.initiator) {\n                socket.emit('third', signalObj);\n              }\n            });\n\n            document.getElementById('connect').addEventListener('click', function () {\n              // if (!peer.initiator) {\n              socket.emit('second', JSON.stringify(roomID));\n              // }\n            });\n\n            socket.on('initialConnected', function () {\n              if (!peer.initiator) {\n                console.log('Initial connected good');\n              }\n            });\n\n            socket.on('secondPart2', function (initialClientSig) {\n              initialClientSig = JSON.parse(initialClientSig);\n              if (!peer.initiator) {\n                peer.signal(initialClientSig);\n              }\n            });\n\n            socket.on('thirdPart2', function (secondClientSig) {\n              secondClientSig = JSON.parse(secondClientSig);\n              if (peer.initiator) {\n                peer.signal(secondClientSig);\n              }\n            });\n\n            socket.on('updateChatters', function (chatter) {\n              chattersClient.splice(chattersClient.indexOf(chatter), 1);\n            });\n\n            peer.on('data', function (data) {\n\n              //parse data string to get the data object\n              var dataObj = JSON.parse(data);\n              //check data object for keys indicating if the type of data is a message\n              if (dataObj.message) {\n                //post message in the text content chat box spot\n                document.getElementById('messages').textContent += dataObj.message + '\\n';\n                //check data object for key indicating clicked the 'filter me!' button\n              } else if (dataObj.myFilter) {\n                //checks the value of the key to see if a filter needs to be added\n                if (dataObj.myFilter === 'yes') {\n                  //applies filter to video to reflect partner's video\n                  setVendorCss(peerVideo, dataObj.filterType);\n                  //checks value of key to see if filter needs to be removed\n                } else if (dataObj.myFilter === 'no') {\n                  //removes filter\n                  peerVideo.removeAttribute('style');\n                }\n\n                //check data object for key indicating user clicked the \"filter them\" button\n              } else if (dataObj.peerFilter) {\n                //checks key value to see if a filter needs to be added\n                if (dataObj.peerFilter === 'yes') {\n                  //applies filter\n                  setVendorCss(myVideo, dataObj.filterType);\n                  //checks key value to see if a filter needs to be removed\n                } else if (dataObj.peerFilter === 'no') {\n                  //removes filter\n                  myVideo.removeAttribute('style');\n                }\n              } else if (dataObj.emoji) {\n\n                //remote display bounce animation!\n                var emoImg = new Image();\n                emoImg.src = dataObj.currentImg;\n\n                temp = currentAnimation;\n                currentAnimation = eval('(' + dataObj.animation + ')');\n                currentAnimation(peerCanvas, peerContext, event, dataObj.position, emoImg);\n                currentAnimation = temp;\n              } else if (dataObj.peerEmoji) {\n\n                //local display bounce animation!\n                var _emoImg = new Image();\n                _emoImg.src = dataObj.currentImg;\n\n                temp = currentAnimation;\n                currentAnimation = eval('(' + dataObj.animation + ')');\n                currentAnimation(myCanvas, myContext, event, dataObj.position, _emoImg);\n                currentAnimation = temp;\n              }\n            });\n\n            //looks for click event on the send button//\n            document.getElementById('send').addEventListener('click', function () {\n\n              //creates a message object with a stringified object containing the local port and the message\n              var yourMessageObj = JSON.stringify({\n                message: peer.localPort + \" \" + document.getElementById('yourMessage').value\n              });\n              //creates a variable with the same information to display on your side\n              //peer.localPort is a temporary way to identify peers, should be changed\n              var yourMessage = peer.localPort + \" \" + document.getElementById('yourMessage').value;\n              //post message in text context on your side\n              document.getElementById('messages').textContent += yourMessage + '\\n';\n              //send message object to the data channel\n              peer.send(yourMessageObj);\n            });\n            //end send click event//\n\n            //click event for the \"filter me\" button//\n            document.getElementById('myFilter').addEventListener('click', function () {\n              var filterDataObj = void 0;\n              //checks for filter and assigns key yes or no based on whether or not one needs to be applied\n              if (!myVideo.style.filter) {\n                //creates and stringify object to send to the data channel with instructions to apply filter\n                filterDataObj = JSON.stringify({\n                  myFilter: 'yes',\n                  filterType: current.innerHTML\n                });\n                //add filter on your side\n                setVendorCss(myVideo, current.innerHTML);\n              } else {\n                //create and stringify object to send to the data channel with instructions to remove filter\n                filterDataObj = JSON.stringify({\n                  myFilter: 'no'\n                });\n                myVideo.removeAttribute('style');\n              }\n              //send object to data channel\n              peer.send(filterDataObj);\n            });\n\n            //click event for the \"filter them\" button\n            document.getElementById('peerFilter').addEventListener('click', function () {\n\n              var filterDataObj = void 0;\n              //checks for filter and assigns key yes or no based on whether one needs to be applied\n              if (!peerVideo.style.filter) {\n                //creates and stringify object to send to the data channel with instructions to apply filter\n                filterDataObj = JSON.stringify({\n                  peerFilter: 'yes',\n                  filterType: current.innerHTML\n                });\n                //add filter on your side\n                setVendorCss(peerVideo, current.innerHTML);\n              } else {\n                //creates and stringify object to send to the data channel with instructions to remove filter\n                filterDataObj = JSON.stringify({\n                  peerFilter: 'no'\n                });\n                //remove filter on your side\n                peerVideo.removeAttribute('style');\n              }\n              //sends object to the data channel\n              peer.send(filterDataObj);\n            });\n            ///end filter them click event///\n\n            //tesing filters//\n            button.addEventListener('click', function () {\n              current.innerHTML = filters[i];\n              i++;\n              if (i >= filters.length) i = 0;\n            }, false);\n            //end of filter test//\n\n            myCanvas.addEventListener('click', function (event) {\n              //gets position based mouse click coordinates, restricted\n              //to canvas rectangle, see function logic in function store\n              var myPosition = getCursorPosition(myCanvas, event);\n\n              var emoImg = new Image();\n              emoImg.src = currentImg;\n\n              var myCanvasObj = JSON.stringify({\n                animation: currentAnimation.toString(),\n                emoji: 'yes',\n                currentImg: currentImg,\n                position: {\n                  x: myPosition.x,\n                  y: myPosition.y\n                }\n              });\n\n              //animation for local display and data transmission to peer\n              currentAnimation(myCanvas, myContext, event, myPosition, emoImg);\n              peer.send(myCanvasObj);\n            }, false);\n            //end of click listener logic//\n\n            // adding buttons to change active animations\n            staticButton.addEventListener('click', function (event) {\n              currentAnimation = staticPaste;\n            });\n\n            bounceButton.addEventListener('click', function (event) {\n              currentAnimation = bounce;\n            });\n\n            orbitButton.addEventListener('click', function (event) {\n              currentAnimation = orbit;\n            });\n\n            clearButton.addEventListener('click', function (event) {\n              cancelAnimationFrame(raf);\n              myContext.clearRect(0, 0, myCanvas.width, myCanvas.height);\n              peerContext.clearRect(0, 0, peerCanvas.width, peerCanvas.height);\n            });\n\n            //adding click handler for active emoji selection\n            var emojis = document.getElementsByClassName('emoji');\n\n            var _loop = function _loop(_i) {\n              emojis[_i].addEventListener('click', function (event) {\n                currentImg = emojis[_i].querySelectorAll('img')[0].getAttribute('src');\n              });\n            };\n\n            for (var _i = 0; _i < emojis.length; _i++) {\n              _loop(_i);\n            }\n\n            //peer stream event//\n            peer.on('stream', function (stream) {\n\n              // peerVideo = document.getElementById('peerVideo')\n              // peerVideo.src = vendorUrl.createObjectURL(stream);\n              // peerVideo.play();\n\n              //uses the stream from the remote webcam and draws it on canvas//\n              peerVirtualVid = document.createElement('video');\n              peerVirtualVid.src = vendorUrl.createObjectURL(stream);\n              peerVirtualVid.play();\n\n              peerVideo = document.getElementById('peerVideo');\n              peerVidCtx = peerVideo.getContext('2d');\n\n              peerVirtualVid.addEventListener('play', function () {\n                peerVideo.width = 640;\n                peerVideo.height = 460;\n                drawVideo(this, peerVidCtx, peerVideo.width, peerVideo.height);\n              }, false);\n              //end remote draw//\n\n              peerCanvas = document.getElementById('peerCanvas');\n              peerContext = peerCanvas.getContext('2d');\n\n              //width and height should eventually be translated to exact coordination\n              //with incoming video stream\n              peerCanvas.width = 640;\n              peerCanvas.height = 460;\n\n              //draws blank canvas on top of video, visibility may be unnecessary\n              peerContext.rect(0, 0, peerCanvas.width, peerCanvas.height);\n              peerContext.stroke();\n\n              //remote display animation this to data channel logic easy peasy\n              peerCanvas.addEventListener('click', function (event) {\n\n                //gets position based mouse click coordinates, restricted\n                //to canvas rectangle, see function logic in function store\n                var peerPosition = getCursorPosition(peerCanvas, event);\n\n                var emoImg = new Image();\n                emoImg.src = currentImg;\n\n                currentAnimation(peerCanvas, peerContext, event, peerPosition, emoImg);\n\n                var peerCanvasObj = JSON.stringify({\n                  animation: currentAnimation.toString(),\n                  peerEmoji: 'yes',\n                  currentImg: currentImg,\n                  position: {\n                    x: peerPosition.x,\n                    y: peerPosition.y\n                  }\n                });\n                peer.send(peerCanvasObj);\n              }, false);\n              //end of click listener logic//\n            });\n            ///end peer stream event///\n          }); //end of socket.on('initiated')\n\n        }, function (err) {\n          console.error(err);\n        });\n      } //end of boolean in socket 'process' event\n    }); //end of socket 'process' event\n  }); //end of 'join' event\n\n\n  //function store//\n\n  function bounce(cv, ctx, evt, pos, emoImg) {\n    var onload = emoImg.onload;\n\n    //this object keeps track of the movement, loads the images, and determines\n    //the velocity\n    var emoticon = {\n      x: pos.x,\n      y: pos.y,\n      vx: 5,\n      vy: 2,\n      onload: function onload() {\n        ctx.drawImage(emoImg, this.x - emoImg.width / 2, this.y - emoImg.height / 2);\n      }\n    };\n\n    //initial image load on canvas\n    emoticon.onload();\n    var callBack = function callBack() {\n      velocity(emoticon, ctx, cv, callBack, emoImg);\n    };\n\n    //start drawing movement\n    raf = window.requestAnimationFrame(callBack);\n  }\n\n  function staticPaste(cv, ctx, evt, pos, emoImg) {\n    var onload = emoImg.onload;\n\n    //this object keeps track of the movement, loads the images, and determines\n    //the velocity\n    var emoticon = {\n      x: pos.x,\n      y: pos.y,\n      vx: 5,\n      vy: 2,\n      onload: function onload() {\n        ctx.drawImage(emoImg, this.x - emoImg.width / 2, this.y - emoImg.height / 2);\n      }\n    };\n    //initial image load on canvas\n    emoticon.onload();\n  }\n\n  //orbit func//\n  function orbit(cv, ctx, evt, pos, emoImg) {\n    var onload = emoImg.onload;\n\n    //this object keeps track of the movement, loads the images, and determines\n    //the angular veloctiy. We're keeping track of frequency of refreshes to\n    //imcrement the degrees\n    var movement = .0349066;\n    var emoticon = {\n      x: pos.x,\n      y: pos.y,\n      r: 5,\n      rotateCount: 1,\n      wx: movement,\n      wy: movement,\n      onload: function onload() {\n        ctx.drawImage(emoImg, this.x - emoImg.width / 2, this.y - emoImg.height / 2);\n      }\n    };\n\n    //initial image load on canvas\n    emoticon.onload();\n\n    var callBack = function callBack() {\n      angularVelocity(emoticon, ctx, cv, callBack, emoImg);\n    };\n\n    //start drawing movement\n    raf = window.requestAnimationFrame(callBack);\n  }\n  //end orbit//\n\n  //paste object to canvas\n  function paste(video, context, width, height, x, y, source) {\n    context.drawImage(video, 0, 0, width, height);\n    baseImg = new Image();\n    baseImg.src = source; // needs to be path ie --> 'assets/weird.png';\n    baseImg.onload = function () {\n      context.drawImage(baseImg, x - baseImg.width / 2, y - baseImg.height / 2);\n      //setTimeout for pasted images//\n      // var time = window.setTimeout(function() {\n      // context.clearRect(x - baseImg.width / 2, y - baseImg.height / 2, baseImg.width, baseImg.height);\n      // }, 5000);\n    };\n  }\n  //end paste//\n\n  //gets cursor position upon mouse click that places\n  //an object or starts object movement\n  function getCursorPosition(canvas, event) {\n    var rect = canvas.getBoundingClientRect();\n    var x = event.clientX - rect.left;\n    var y = event.clientY - rect.top;\n    var pos = {\n      x: x,\n      y: y\n    };\n    return pos;\n  }\n  //end getCursorPosition//\n\n  //streamline vendor prefixing for css filtering\n  function setVendorCss(element, style) {\n    element.style.webkitFilter = style;\n    element.style.mozFilter = style;\n    element.style.filter = style;\n  }\n  //end setVendorCss //\n\n  //draws video on canvas\n  function drawVideo(v, c, w, h) {\n    if (v.paused || v.ended) return false;\n    c.drawImage(v, 0, 0, w, h);\n    setTimeout(drawVideo, 20, v, c, w, h);\n  }\n  //end drawVideo//\n\n  //canvas draw function for velocity motion\n  function velocity(obj, ctx, cv, cb, emoImg) {\n    ctx.clearRect(obj.x - emoImg.width / 2 - 5, obj.y - emoImg.height / 2 - 5, emoImg.width + 8, emoImg.height + 8);\n    obj.onload();\n    obj.x += obj.vx;\n    obj.y += obj.vy;\n    if (obj.y + obj.vy > cv.height || obj.y + obj.vy < 0) {\n      obj.vy = -obj.vy;\n    }\n    if (obj.x + obj.vx > cv.width || obj.x + obj.vx < 0) {\n      obj.vx = -obj.vx;\n    }\n    raf = window.requestAnimationFrame(cb);\n  }\n  //end velocity//\n\n  //angularVelocity func//\n  function angularVelocity(obj, ctx, cv, cb, emoImg) {\n    ctx.clearRect(obj.x - emoImg.width / 2 - 5, obj.y - emoImg.height / 2 - 5, emoImg.width + 10, emoImg.height + 10);\n    obj.onload();\n\n    obj.x += Math.sin(obj.wx * obj.rotateCount) * obj.r;\n    obj.y += Math.cos(obj.wy * obj.rotateCount) * obj.r;\n    obj.rotateCount++;\n\n    raf = window.requestAnimationFrame(cb);\n  }\n  //end angularVelocity//\n\n  //doesnt work yet, but would provide a way to erase drawn\n  //objects in circular fashion rather than rectangular\n  function cutCircle(context, x, y, radius) {\n    context.globalCompositeOperation = 'destination-out';\n    context.arc(x, y, radius, 0, Math.PI * 2, true);\n    context.fill();\n  }\n  //end cutCircle//\n\n  ///end of function store///\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9pbmRleC5qcz8xNjg3Il0sInNvdXJjZXNDb250ZW50IjpbImRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgLy92YXJpYWJsZSBzdG9yZS8vXG4gIGxldCB2ZW5kb3JVcmwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwsXG4gICAgcGVlcixcbiAgICBjaGF0dGVyc0NsaWVudCA9IFtdLFxuICAgIGNoYXR0ZXJUaGlzQ2xpZW50LFxuICAgIHJvb21JRCxcbiAgICAvL3ZhcmlhYmxlcyBmb3IgdmlkZW8sIHBlZXJDYW52YXMsIGFuZCBjb250ZXh0IGxvZ2ljXG4gICAgcGVlclZpZGVvLFxuICAgIHBlZXJDYW52YXMsXG4gICAgcGVlckNvbnRleHQsXG4gICAgbXlDYW52YXMsXG4gICAgbXlWaWRlbywgLy92aWRlbyBjYW52YXNcbiAgICBteVZpZEN0eCxcbiAgICBteUNvbnRleHQsXG4gICAgcGVlclZpZEN0eCxcbiAgICBwZWVyVmlydHVhbFZpZCxcbiAgICAvL3ZhcmlhYmxlcyBmb3IgZmlsdGVyIGxvZ2ljXG4gICAgY3VycmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWx0ZXJEaXNwJyksXG4gICAgYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlcicpLFxuICAgIGZpbHRlcnMgPSBbJ2JsdXIoNXB4KScsICdicmlnaHRuZXNzKDAuNCknLCAnY29udHJhc3QoMjAwJSknLCAnZ3JheXNjYWxlKDEwMCUpJywgJ2h1ZS1yb3RhdGUoOTBkZWcpJywgJ2ludmVydCgxMDAlKScsICdzZXBpYSgxMDAlKScsICdzYXR1cmF0ZSgyMCknLCAnJ10sXG4gICAgaSA9IDAsXG4gICAgLy9jbGVhciBjYW52YXNcbiAgICBjbGVhckJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGVhcicpLFxuICAgIC8vYW5pbWF0aW9uIHZhcmlhYmxlc1xuICAgIHN0YXRpY0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0aWMnKSxcbiAgICBib3VuY2VCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm91bmNlJyksXG4gICAgb3JiaXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXQnKSxcbiAgICBjdXJyZW50QW5pbWF0aW9uID0gYm91bmNlLFxuICAgIHRlbXAsXG4gICAgLy9yb29tIGJ1dHRvbnNcbiAgICBqb2luQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2pvaW4tYnV0dG9uJyksXG4gICAgcmFuZG9tQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmRvbS1idXR0b24nKSxcbiAgICAvL3JhZiBzdGFuZHMgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgZW5hYmxlcyBkcmF3aW5nIHRvIG9jY3VyXG4gICAgcmFmO1xuXG4gIC8vaW1hZ2UgYXNzaWdubWVudCwgd2UgY2FuIGFic3RyYWN0IHRoaXMgbGF0ZXJcbiAgLy8gbGV0IGVtb0ltZyA9IG5ldyBJbWFnZSgpO1xuICBsZXQgY3VycmVudEltZyA9ICdhc3NldHMvc21Mb3ZlVG9uZ3VlLnBuZyc7XG5cbiAgY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgLy9lbmQgdmFyaWFibGUgc3RvcmUvL1xuXG4gIC8vdmVuZG9yIG1lZGlhIG9iamVjdHMvL1xuICBuYXZpZ2F0b3IuZ2V0TWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8XG4gICAgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhO1xuICAvL2VuZCB2ZW5kb3IgbWVkaWEgb2JqZWN0cy8vXG5cbiAgLy9yb29tIHNlbGVjdGlvblxuICBqb2luQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICByb29tSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vbS1pZC1pbnB1dCcpLnZhbHVlO1xuICAgICAgc29ja2V0LmVtaXQoJ2pvaW5Sb29tJywgSlNPTi5zdHJpbmdpZnkocm9vbUlEKSk7XG4gICAgICAvLyBzb2NrZXQub24oJ3RyeUFnYWluJywgKHBheWxvYWQpID0+IGFsZXJ0KCdUcnkgYSBkaWZmZXJlbnQgcm9vbSEnKSlcblxuICAgICAgc29ja2V0Lm9uKCdwcm9jZXNzJywgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnaW4gcHJvY2VzcycsIHBheWxvYWQpXG4gICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICAgICAgY29uc29sZS5sb2cocGF5bG9hZClcbiAgICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdUcnkgYSBkaWZmZXJlbnQgcm9vbSEnKVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb29tQXBwJykuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkFwcCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAgIC8vYmVnaW4gc3RyZWFtaW5nIS8vXG4gICAgICAgICAgICBuYXZpZ2F0b3IuZ2V0TWVkaWEoe1xuICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihzdHJlYW0pIHtcblxuXG4gICAgICAgICAgICAgICAgLy9tYWtlIGluaXRpYXRlIGV2ZW50IGhhcHBlbiBhdXRvbWF0aWNhbGx5IHdoZW4gc3RyZWFtaW5nIGJlZ2luc1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdpbml0aWF0ZScsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9vbUlkOiByb29tSURcbiAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH0pKCk7XG5cblxuICAgICAgICAgICAgICAgIHNvY2tldC5vbigncmVhZHlDb25uZWN0JywgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25uZWN0JykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdpbml0aWF0ZWQnLCAobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IEpTT04ucGFyc2UobWVtYmVyKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vbUFwcCcpLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkFwcCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlcyB0aGUgc3RyZWFtIGZyb20gdGhlIGxvY2FsIHdlYmNhbSBhbmQgZHJhd3MgaXQgb24gY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgbGV0IG15VmlydHVhbFZpZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgIG15VmlydHVhbFZpZC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBteVZpcnR1YWxWaWQucGxheSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZHJhdyBsb2NhbCB2aWQgb24gY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgbXlWaWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteVZpZGVvJylcbiAgICAgICAgICAgICAgICAgICAgbXlWaWRDdHggPSBteVZpZGVvLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbXlWaXJ0dWFsVmlkLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkcmF3VmlkZW8odGhpcywgbXlWaWRDdHgsIG15VmlkZW8ud2lkdGgsIG15VmlkZW8uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvL2VuZC8vXG5cbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3IGxvY2FsIG92ZXJsYXkgY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgbXlDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlDYW52YXMnKVxuICAgICAgICAgICAgICAgICAgICBteUNvbnRleHQgPSBteUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vd2lkdGggYW5kIGhlaWdodCBzaG91bGQgZXZlbnR1YWxseSBiZSB0cmFuc2xhdGVkIHRvIGV4YWN0IGNvb3JkaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAvL3dpdGggaW5jb21pbmcgdmlkZW8gc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgIG15Q2FudmFzLndpZHRoID0gNjQwO1xuICAgICAgICAgICAgICAgICAgICBteUNhbnZhcy5oZWlnaHQgPSA0ODA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9kcmF3cyBibGFuayBjYW52YXMgb24gdG9wIG9mIHZpZGVvXG4gICAgICAgICAgICAgICAgICAgIG15Q29udGV4dC5yZWN0KDAsIDAsIG15Q2FudmFzLndpZHRoLCBteUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBteUNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vZW5kLy9cblxuICAgICAgICAgICAgICAgICAgICAvL3NldCByb29tIElEIHNoYXJlZCBiZXR3ZWVuIGNsaWVudHNcbiAgICAgICAgICAgICAgICAgICAgcm9vbUlEID0gbWVtYmVyLnJvb21JZDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhdHRlcnNDbGllbnQuZmlsdGVyKGNsaWVudENoYXR0ZXIgPT4gY2xpZW50Q2hhdHRlci5pZCAhPT0gbWVtYmVyLmlkKS5sZW5ndGggfHwgIWNoYXR0ZXJzQ2xpZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXR0ZXJzQ2xpZW50LnB1c2gobWVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGF0dGVyVGhpc0NsaWVudCA9IG1lbWJlci5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vaW5zdGFudGlhdGUgcGVlciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcGVlciA9IG5ldyBTaW1wbGVQZWVyKHtcbiAgICAgICAgICAgICAgICAgICAgICBpbml0aWF0b3I6IG1lbWJlci5pbml0aWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdHJpY2tsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBwZWVyLm9uKCdzaWduYWwnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3lvdXJJZCcpLnZhbHVlID0gXCJDb25uZWN0ZWQhXCI7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHNpZ25hbE9iaiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21JZDogcm9vbUlELFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVlci5pbml0aWF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdpbml0aWFsJywgc2lnbmFsT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwZWVyLmluaXRpYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ3RoaXJkJywgc2lnbmFsT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nvbm5lY3QnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICghcGVlci5pbml0aWF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdzZWNvbmQnLCBKU09OLnN0cmluZ2lmeShyb29tSUQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbignaW5pdGlhbENvbm5lY3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVlci5pbml0aWF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsIGNvbm5lY3RlZCBnb29kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub24oJ3NlY29uZFBhcnQyJywgKGluaXRpYWxDbGllbnRTaWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ2xpZW50U2lnID0gSlNPTi5wYXJzZShpbml0aWFsQ2xpZW50U2lnKVxuICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVlci5pbml0aWF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXIuc2lnbmFsKGluaXRpYWxDbGllbnRTaWcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCd0aGlyZFBhcnQyJywgZnVuY3Rpb24oc2Vjb25kQ2xpZW50U2lnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2Vjb25kQ2xpZW50U2lnID0gSlNPTi5wYXJzZShzZWNvbmRDbGllbnRTaWcpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVyLmluaXRpYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVlci5zaWduYWwoc2Vjb25kQ2xpZW50U2lnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbigndXBkYXRlQ2hhdHRlcnMnLCAoY2hhdHRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXR0ZXJzQ2xpZW50LnNwbGljZShjaGF0dGVyc0NsaWVudC5pbmRleE9mKGNoYXR0ZXIpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgICAgICBwZWVyLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy9wYXJzZSBkYXRhIHN0cmluZyB0byBnZXQgdGhlIGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFPYmogPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZGF0YSBvYmplY3QgZm9yIGtleXMgaW5kaWNhdGluZyBpZiB0aGUgdHlwZSBvZiBkYXRhIGlzIGEgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhT2JqLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcG9zdCBtZXNzYWdlIGluIHRoZSB0ZXh0IGNvbnRlbnQgY2hhdCBib3ggc3BvdFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lc3NhZ2VzJykudGV4dENvbnRlbnQgKz0gZGF0YU9iai5tZXNzYWdlICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGRhdGEgb2JqZWN0IGZvciBrZXkgaW5kaWNhdGluZyBjbGlja2VkIHRoZSAnZmlsdGVyIG1lIScgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhT2JqLm15RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcyB0aGUgdmFsdWUgb2YgdGhlIGtleSB0byBzZWUgaWYgYSBmaWx0ZXIgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhT2JqLm15RmlsdGVyID09PSAneWVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGxpZXMgZmlsdGVyIHRvIHZpZGVvIHRvIHJlZmxlY3QgcGFydG5lcidzIHZpZGVvXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZlbmRvckNzcyhwZWVyVmlkZW8sIGRhdGFPYmouZmlsdGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tzIHZhbHVlIG9mIGtleSB0byBzZWUgaWYgZmlsdGVyIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YU9iai5teUZpbHRlciA9PT0gJ25vJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZXMgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaWRlby5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZGF0YSBvYmplY3QgZm9yIGtleSBpbmRpY2F0aW5nIHVzZXIgY2xpY2tlZCB0aGUgXCJmaWx0ZXIgdGhlbVwiIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YU9iai5wZWVyRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcyBrZXkgdmFsdWUgdG8gc2VlIGlmIGEgZmlsdGVyIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YU9iai5wZWVyRmlsdGVyID09PSAneWVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGxpZXMgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZlbmRvckNzcyhteVZpZGVvLCBkYXRhT2JqLmZpbHRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcyBrZXkgdmFsdWUgdG8gc2VlIGlmIGEgZmlsdGVyIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YU9iai5wZWVyRmlsdGVyID09PSAnbm8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlcyBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXlWaWRlby5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhT2JqLmVtb2ppKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3RlIGRpc3BsYXkgYm91bmNlIGFuaW1hdGlvbiFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbW9JbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtb0ltZy5zcmMgPSBkYXRhT2JqLmN1cnJlbnRJbWc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjdXJyZW50QW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGV2YWwoJygnICsgZGF0YU9iai5hbmltYXRpb24gKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbihwZWVyQ2FudmFzLCBwZWVyQ29udGV4dCwgZXZlbnQsIGRhdGFPYmoucG9zaXRpb24sIGVtb0ltZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gdGVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YU9iai5wZWVyRW1vamkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2NhbCBkaXNwbGF5IGJvdW5jZSBhbmltYXRpb24hXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW1vSW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbW9JbWcuc3JjID0gZGF0YU9iai5jdXJyZW50SW1nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24gPSBldmFsKCcoJyArIGRhdGFPYmouYW5pbWF0aW9uICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24obXlDYW52YXMsIG15Q29udGV4dCwgZXZlbnQsIGRhdGFPYmoucG9zaXRpb24sIGVtb0ltZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vbG9va3MgZm9yIGNsaWNrIGV2ZW50IG9uIHRoZSBzZW5kIGJ1dHRvbi8vXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZW5kJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGVzIGEgbWVzc2FnZSBvYmplY3Qgd2l0aCBhIHN0cmluZ2lmaWVkIG9iamVjdCBjb250YWluaW5nIHRoZSBsb2NhbCBwb3J0IGFuZCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHlvdXJNZXNzYWdlT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwZWVyLmxvY2FsUG9ydCArIFwiIFwiICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3lvdXJNZXNzYWdlJykudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGVzIGEgdmFyaWFibGUgd2l0aCB0aGUgc2FtZSBpbmZvcm1hdGlvbiB0byBkaXNwbGF5IG9uIHlvdXIgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wZWVyLmxvY2FsUG9ydCBpcyBhIHRlbXBvcmFyeSB3YXkgdG8gaWRlbnRpZnkgcGVlcnMsIHNob3VsZCBiZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeW91ck1lc3NhZ2UgPSBwZWVyLmxvY2FsUG9ydCArIFwiIFwiICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3lvdXJNZXNzYWdlJykudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Bvc3QgbWVzc2FnZSBpbiB0ZXh0IGNvbnRleHQgb24geW91ciBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZXMnKS50ZXh0Q29udGVudCArPSB5b3VyTWVzc2FnZSArICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZW5kIG1lc3NhZ2Ugb2JqZWN0IHRvIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXIuc2VuZCh5b3VyTWVzc2FnZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAvL2VuZCBzZW5kIGNsaWNrIGV2ZW50Ly9cblxuICAgICAgICAgICAgICAgICAgICAvL2NsaWNrIGV2ZW50IGZvciB0aGUgXCJmaWx0ZXIgbWVcIiBidXR0b24vL1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlGaWx0ZXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJEYXRhT2JqO1xuICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tzIGZvciBmaWx0ZXIgYW5kIGFzc2lnbnMga2V5IHllcyBvciBubyBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBvbmUgbmVlZHMgdG8gYmUgYXBwbGllZFxuICAgICAgICAgICAgICAgICAgICAgIGlmICghbXlWaWRlby5zdHlsZS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlcyBhbmQgc3RyaW5naWZ5IG9iamVjdCB0byBzZW5kIHRvIHRoZSBkYXRhIGNoYW5uZWwgd2l0aCBpbnN0cnVjdGlvbnMgdG8gYXBwbHkgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBteUZpbHRlcjogJ3llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclR5cGU6IGN1cnJlbnQuaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIGZpbHRlciBvbiB5b3VyIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZlbmRvckNzcyhteVZpZGVvLCBjdXJyZW50LmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGFuZCBzdHJpbmdpZnkgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGRhdGEgY2hhbm5lbCB3aXRoIGluc3RydWN0aW9ucyB0byByZW1vdmUgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhT2JqID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBteUZpbHRlcjogJ25vJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteVZpZGVvLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy9zZW5kIG9iamVjdCB0byBkYXRhIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyLnNlbmQoZmlsdGVyRGF0YU9iaik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgLy9jbGljayBldmVudCBmb3IgdGhlIFwiZmlsdGVyIHRoZW1cIiBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BlZXJGaWx0ZXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlckRhdGFPYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcyBmb3IgZmlsdGVyIGFuZCBhc3NpZ25zIGtleSB5ZXMgb3Igbm8gYmFzZWQgb24gd2hldGhlciBvbmUgbmVlZHMgdG8gYmUgYXBwbGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZWVyVmlkZW8uc3R5bGUuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlcyBhbmQgc3RyaW5naWZ5IG9iamVjdCB0byBzZW5kIHRvIHRoZSBkYXRhIGNoYW5uZWwgd2l0aCBpbnN0cnVjdGlvbnMgdG8gYXBwbHkgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGFPYmogPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVlckZpbHRlcjogJ3llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyVHlwZTogY3VycmVudC5pbm5lckhUTUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIGZpbHRlciBvbiB5b3VyIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmVuZG9yQ3NzKHBlZXJWaWRlbywgY3VycmVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGVzIGFuZCBzdHJpbmdpZnkgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGRhdGEgY2hhbm5lbCB3aXRoIGluc3RydWN0aW9ucyB0byByZW1vdmUgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGFPYmogPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVlckZpbHRlcjogJ25vJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgZmlsdGVyIG9uIHlvdXIgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlkZW8ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZW5kcyBvYmplY3QgdG8gdGhlIGRhdGEgY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlci5zZW5kKGZpbHRlckRhdGFPYmopO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLy8vZW5kIGZpbHRlciB0aGVtIGNsaWNrIGV2ZW50Ly8vXG5cbiAgICAgICAgICAgICAgICAgICAgLy90ZXNpbmcgZmlsdGVycy8vXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuaW5uZXJIVE1MID0gZmlsdGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gZmlsdGVycy5sZW5ndGgpIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vZW5kIG9mIGZpbHRlciB0ZXN0Ly9cblxuICAgICAgICAgICAgICAgICAgICBteUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldHMgcG9zaXRpb24gYmFzZWQgbW91c2UgY2xpY2sgY29vcmRpbmF0ZXMsIHJlc3RyaWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG8gY2FudmFzIHJlY3RhbmdsZSwgc2VlIGZ1bmN0aW9uIGxvZ2ljIGluIGZ1bmN0aW9uIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXlQb3NpdGlvbiA9IGdldEN1cnNvclBvc2l0aW9uKG15Q2FudmFzLCBldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbW9JbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtb0ltZy5zcmMgPSBjdXJyZW50SW1nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXlDYW52YXNPYmogPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogY3VycmVudEFuaW1hdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbW9qaTogJ3llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbWc6IGN1cnJlbnRJbWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbXlQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG15UG9zaXRpb24ueVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmltYXRpb24gZm9yIGxvY2FsIGRpc3BsYXkgYW5kIGRhdGEgdHJhbnNtaXNzaW9uIHRvIHBlZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24obXlDYW52YXMsIG15Q29udGV4dCwgZXZlbnQsIG15UG9zaXRpb24sIGVtb0ltZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyLnNlbmQobXlDYW52YXNPYmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgLy9lbmQgb2YgY2xpY2sgbGlzdGVuZXIgbG9naWMvL1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyBidXR0b25zIHRvIGNoYW5nZSBhY3RpdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb24gPSBzdGF0aWNQYXN0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYm91bmNlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gYm91bmNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBvcmJpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IG9yYml0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjbGVhckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgICAgICAgICAgICAgICAgICBteUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIG15Q2FudmFzLndpZHRoLCBteUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBwZWVyQ2FudmFzLndpZHRoLCBwZWVyQ2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hZGRpbmcgY2xpY2sgaGFuZGxlciBmb3IgYWN0aXZlIGVtb2ppIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbW9qaXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdlbW9qaScpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVtb2ppcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgZW1vamlzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbWcgPSBlbW9qaXNbaV0ucXVlcnlTZWxlY3RvckFsbCgnaW1nJylbMF0uZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSl9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9wZWVyIHN0cmVhbSBldmVudC8vXG4gICAgICAgICAgICAgICAgICAgIHBlZXIub24oJ3N0cmVhbScsIGZ1bmN0aW9uKHN0cmVhbSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcGVlclZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BlZXJWaWRlbycpXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcGVlclZpZGVvLnNyYyA9IHZlbmRvclVybC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwZWVyVmlkZW8ucGxheSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy91c2VzIHRoZSBzdHJlYW0gZnJvbSB0aGUgcmVtb3RlIHdlYmNhbSBhbmQgZHJhd3MgaXQgb24gY2FudmFzLy9cbiAgICAgICAgICAgICAgICAgICAgICBwZWVyVmlydHVhbFZpZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVlclZpcnR1YWxWaWQuc3JjID0gdmVuZG9yVXJsLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaXJ0dWFsVmlkLnBsYXkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZWVyVmlkZW8nKVxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaWRDdHggPSBwZWVyVmlkZW8uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaXJ0dWFsVmlkLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaWRlby53aWR0aCA9IDY0MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJWaWRlby5oZWlnaHQgPSA0NjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VmlkZW8odGhpcywgcGVlclZpZEN0eCwgcGVlclZpZGVvLndpZHRoLCBwZWVyVmlkZW8uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgLy9lbmQgcmVtb3RlIGRyYXcvL1xuXG4gICAgICAgICAgICAgICAgICAgICAgcGVlckNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwZWVyQ2FudmFzJylcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQ29udGV4dCA9IHBlZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vd2lkdGggYW5kIGhlaWdodCBzaG91bGQgZXZlbnR1YWxseSBiZSB0cmFuc2xhdGVkIHRvIGV4YWN0IGNvb3JkaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAgIC8vd2l0aCBpbmNvbWluZyB2aWRlbyBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQ2FudmFzLndpZHRoID0gNjQwO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJDYW52YXMuaGVpZ2h0ID0gNDYwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy9kcmF3cyBibGFuayBjYW52YXMgb24gdG9wIG9mIHZpZGVvLCB2aXNpYmlsaXR5IG1heSBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJDb250ZXh0LnJlY3QoMCwgMCwgcGVlckNhbnZhcy53aWR0aCwgcGVlckNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJDb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdGUgZGlzcGxheSBhbmltYXRpb24gdGhpcyB0byBkYXRhIGNoYW5uZWwgbG9naWMgZWFzeSBwZWFzeVxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0cyBwb3NpdGlvbiBiYXNlZCBtb3VzZSBjbGljayBjb29yZGluYXRlcywgcmVzdHJpY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RvIGNhbnZhcyByZWN0YW5nbGUsIHNlZSBmdW5jdGlvbiBsb2dpYyBpbiBmdW5jdGlvbiBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGVlclBvc2l0aW9uID0gZ2V0Q3Vyc29yUG9zaXRpb24ocGVlckNhbnZhcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbW9JbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW1vSW1nLnNyYyA9IGN1cnJlbnRJbWc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbihwZWVyQ2FudmFzLCBwZWVyQ29udGV4dCwgZXZlbnQsIHBlZXJQb3NpdGlvbiwgZW1vSW1nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGVlckNhbnZhc09iaiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGN1cnJlbnRBbmltYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVyRW1vamk6ICd5ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbWc6IGN1cnJlbnRJbWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBlZXJQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcGVlclBvc2l0aW9uLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWVyLnNlbmQocGVlckNhbnZhc09iaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbmQgb2YgY2xpY2sgbGlzdGVuZXIgbG9naWMvL1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLy9lbmQgcGVlciBzdHJlYW0gZXZlbnQvLy9cbiAgICAgICAgICAgICAgICAgIH0pIC8vZW5kIG9mIHNvY2tldC5vbignaW5pdGlhdGVkJylcblxuXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IC8vZW5kIG9mIGJvb2xlYW4gaW4gc29ja2V0ICdwcm9jZXNzJyBldmVudFxuXG4gICAgICAgIH0pIC8vZW5kIG9mIHNvY2tldCAncHJvY2VzcycgZXZlbnRcblxuICAgIH0pIC8vZW5kIG9mICdqb2luJyBldmVudFxuXG5cbiAgLy9mdW5jdGlvbiBzdG9yZS8vXG5cbiAgZnVuY3Rpb24gYm91bmNlKGN2LCBjdHgsIGV2dCwgcG9zLCBlbW9JbWcpIHtcbiAgICBsZXQgb25sb2FkID0gZW1vSW1nLm9ubG9hZDtcblxuICAgIC8vdGhpcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgdGhlIG1vdmVtZW50LCBsb2FkcyB0aGUgaW1hZ2VzLCBhbmQgZGV0ZXJtaW5lc1xuICAgIC8vdGhlIHZlbG9jaXR5XG4gICAgbGV0IGVtb3RpY29uID0ge1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueSxcbiAgICAgIHZ4OiA1LFxuICAgICAgdnk6IDIsXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGVtb0ltZywgdGhpcy54IC0gZW1vSW1nLndpZHRoIC8gMiwgdGhpcy55IC0gZW1vSW1nLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvL2luaXRpYWwgaW1hZ2UgbG9hZCBvbiBjYW52YXNcbiAgICBlbW90aWNvbi5vbmxvYWQoKTtcbiAgICBsZXQgY2FsbEJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZlbG9jaXR5KGVtb3RpY29uLCBjdHgsIGN2LCBjYWxsQmFjaywgZW1vSW1nKTtcbiAgICB9XG5cbiAgICAvL3N0YXJ0IGRyYXdpbmcgbW92ZW1lbnRcbiAgICByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxCYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRpY1Bhc3RlKGN2LCBjdHgsIGV2dCwgcG9zLCBlbW9JbWcpIHtcbiAgICBsZXQgb25sb2FkID0gZW1vSW1nLm9ubG9hZDtcblxuICAgIC8vdGhpcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgdGhlIG1vdmVtZW50LCBsb2FkcyB0aGUgaW1hZ2VzLCBhbmQgZGV0ZXJtaW5lc1xuICAgIC8vdGhlIHZlbG9jaXR5XG4gICAgbGV0IGVtb3RpY29uID0ge1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueSxcbiAgICAgIHZ4OiA1LFxuICAgICAgdnk6IDIsXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGVtb0ltZywgdGhpcy54IC0gZW1vSW1nLndpZHRoIC8gMiwgdGhpcy55IC0gZW1vSW1nLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy9pbml0aWFsIGltYWdlIGxvYWQgb24gY2FudmFzXG4gICAgZW1vdGljb24ub25sb2FkKCk7XG4gIH1cblxuICAvL29yYml0IGZ1bmMvL1xuICBmdW5jdGlvbiBvcmJpdChjdiwgY3R4LCBldnQsIHBvcywgZW1vSW1nKSB7XG4gICAgbGV0IG9ubG9hZCA9IGVtb0ltZy5vbmxvYWQ7XG5cbiAgICAvL3RoaXMgb2JqZWN0IGtlZXBzIHRyYWNrIG9mIHRoZSBtb3ZlbWVudCwgbG9hZHMgdGhlIGltYWdlcywgYW5kIGRldGVybWluZXNcbiAgICAvL3RoZSBhbmd1bGFyIHZlbG9jdGl5LiBXZSdyZSBrZWVwaW5nIHRyYWNrIG9mIGZyZXF1ZW5jeSBvZiByZWZyZXNoZXMgdG9cbiAgICAvL2ltY3JlbWVudCB0aGUgZGVncmVlc1xuICAgIGxldCBtb3ZlbWVudCA9IC4wMzQ5MDY2O1xuICAgIGxldCBlbW90aWNvbiA9IHtcbiAgICAgIHg6IHBvcy54LFxuICAgICAgeTogcG9zLnksXG4gICAgICByOiA1LFxuICAgICAgcm90YXRlQ291bnQ6IDEsXG4gICAgICB3eDogbW92ZW1lbnQsXG4gICAgICB3eTogbW92ZW1lbnQsXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGVtb0ltZywgdGhpcy54IC0gZW1vSW1nLndpZHRoIC8gMiwgdGhpcy55IC0gZW1vSW1nLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvL2luaXRpYWwgaW1hZ2UgbG9hZCBvbiBjYW52YXNcbiAgICBlbW90aWNvbi5vbmxvYWQoKTtcblxuICAgIGxldCBjYWxsQmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgYW5ndWxhclZlbG9jaXR5KGVtb3RpY29uLCBjdHgsIGN2LCBjYWxsQmFjaywgZW1vSW1nKTtcbiAgICB9XG5cbiAgICAvL3N0YXJ0IGRyYXdpbmcgbW92ZW1lbnRcbiAgICByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxCYWNrKTtcbiAgfVxuICAvL2VuZCBvcmJpdC8vXG5cbiAgLy9wYXN0ZSBvYmplY3QgdG8gY2FudmFzXG4gIGZ1bmN0aW9uIHBhc3RlKHZpZGVvLCBjb250ZXh0LCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBzb3VyY2UpIHtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgYmFzZUltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGJhc2VJbWcuc3JjID0gc291cmNlOyAvLyBuZWVkcyB0byBiZSBwYXRoIGllIC0tPiAnYXNzZXRzL3dlaXJkLnBuZyc7XG4gICAgYmFzZUltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGJhc2VJbWcsIHggLSBiYXNlSW1nLndpZHRoIC8gMiwgeSAtIGJhc2VJbWcuaGVpZ2h0IC8gMik7XG4gICAgICAvL3NldFRpbWVvdXQgZm9yIHBhc3RlZCBpbWFnZXMvL1xuICAgICAgLy8gdmFyIHRpbWUgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnRleHQuY2xlYXJSZWN0KHggLSBiYXNlSW1nLndpZHRoIC8gMiwgeSAtIGJhc2VJbWcuaGVpZ2h0IC8gMiwgYmFzZUltZy53aWR0aCwgYmFzZUltZy5oZWlnaHQpO1xuICAgICAgLy8gfSwgNTAwMCk7XG4gICAgfVxuICB9XG4gIC8vZW5kIHBhc3RlLy9cblxuICAvL2dldHMgY3Vyc29yIHBvc2l0aW9uIHVwb24gbW91c2UgY2xpY2sgdGhhdCBwbGFjZXNcbiAgLy9hbiBvYmplY3Qgb3Igc3RhcnRzIG9iamVjdCBtb3ZlbWVudFxuICBmdW5jdGlvbiBnZXRDdXJzb3JQb3NpdGlvbihjYW52YXMsIGV2ZW50KSB7XG4gICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIGxldCB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIGxldCBwb3MgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICAvL2VuZCBnZXRDdXJzb3JQb3NpdGlvbi8vXG5cbiAgLy9zdHJlYW1saW5lIHZlbmRvciBwcmVmaXhpbmcgZm9yIGNzcyBmaWx0ZXJpbmdcbiAgZnVuY3Rpb24gc2V0VmVuZG9yQ3NzKGVsZW1lbnQsIHN0eWxlKSB7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRGaWx0ZXIgPSBzdHlsZTtcbiAgICBlbGVtZW50LnN0eWxlLm1vekZpbHRlciA9IHN0eWxlO1xuICAgIGVsZW1lbnQuc3R5bGUuZmlsdGVyID0gc3R5bGU7XG4gIH1cbiAgLy9lbmQgc2V0VmVuZG9yQ3NzIC8vXG5cbiAgLy9kcmF3cyB2aWRlbyBvbiBjYW52YXNcbiAgZnVuY3Rpb24gZHJhd1ZpZGVvKHYsIGMsIHcsIGgpIHtcbiAgICBpZiAodi5wYXVzZWQgfHwgdi5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGMuZHJhd0ltYWdlKHYsIDAsIDAsIHcsIGgpO1xuICAgIHNldFRpbWVvdXQoZHJhd1ZpZGVvLCAyMCwgdiwgYywgdywgaCk7XG4gIH1cbiAgLy9lbmQgZHJhd1ZpZGVvLy9cblxuICAvL2NhbnZhcyBkcmF3IGZ1bmN0aW9uIGZvciB2ZWxvY2l0eSBtb3Rpb25cbiAgZnVuY3Rpb24gdmVsb2NpdHkob2JqLCBjdHgsIGN2LCBjYiwgZW1vSW1nKSB7XG4gICAgY3R4LmNsZWFyUmVjdChvYmoueCAtIGVtb0ltZy53aWR0aCAvIDIgLSA1LCBvYmoueSAtIGVtb0ltZy5oZWlnaHQgLyAyIC0gNSwgZW1vSW1nLndpZHRoICsgOCwgZW1vSW1nLmhlaWdodCArIDgpO1xuICAgIG9iai5vbmxvYWQoKTtcbiAgICBvYmoueCArPSBvYmoudng7XG4gICAgb2JqLnkgKz0gb2JqLnZ5O1xuICAgIGlmIChvYmoueSArIG9iai52eSA+IGN2LmhlaWdodCB8fCBvYmoueSArIG9iai52eSA8IDApIHtcbiAgICAgIG9iai52eSA9IC1vYmoudnk7XG4gICAgfVxuICAgIGlmIChvYmoueCArIG9iai52eCA+IGN2LndpZHRoIHx8IG9iai54ICsgb2JqLnZ4IDwgMCkge1xuICAgICAgb2JqLnZ4ID0gLW9iai52eDtcbiAgICB9XG4gICAgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH1cbiAgLy9lbmQgdmVsb2NpdHkvL1xuXG4gIC8vYW5ndWxhclZlbG9jaXR5IGZ1bmMvL1xuICBmdW5jdGlvbiBhbmd1bGFyVmVsb2NpdHkob2JqLCBjdHgsIGN2LCBjYiwgZW1vSW1nKSB7XG4gICAgY3R4LmNsZWFyUmVjdChvYmoueCAtIGVtb0ltZy53aWR0aCAvIDIgLSA1LCBvYmoueSAtIGVtb0ltZy5oZWlnaHQgLyAyIC0gNSwgZW1vSW1nLndpZHRoICsgMTAsIGVtb0ltZy5oZWlnaHQgKyAxMCk7XG4gICAgb2JqLm9ubG9hZCgpO1xuXG4gICAgb2JqLnggKz0gTWF0aC5zaW4ob2JqLnd4ICogb2JqLnJvdGF0ZUNvdW50KSAqIG9iai5yO1xuICAgIG9iai55ICs9IE1hdGguY29zKG9iai53eSAqIG9iai5yb3RhdGVDb3VudCkgKiBvYmoucjtcbiAgICBvYmoucm90YXRlQ291bnQrKztcblxuICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICB9XG4gIC8vZW5kIGFuZ3VsYXJWZWxvY2l0eS8vXG5cbiAgLy9kb2VzbnQgd29yayB5ZXQsIGJ1dCB3b3VsZCBwcm92aWRlIGEgd2F5IHRvIGVyYXNlIGRyYXduXG4gIC8vb2JqZWN0cyBpbiBjaXJjdWxhciBmYXNoaW9uIHJhdGhlciB0aGFuIHJlY3Rhbmd1bGFyXG4gIGZ1bmN0aW9uIGN1dENpcmNsZShjb250ZXh0LCB4LCB5LCByYWRpdXMpIHtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnXG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgLy9lbmQgY3V0Q2lyY2xlLy9cblxuICAvLy9lbmQgb2YgZnVuY3Rpb24gc3RvcmUvLy9cblxufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBpbmRleC5qc1xuICoqLyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBWEE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUF2QkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTJCQTtBQUNBO0FBN0JBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFKQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqUkE7QUFrUkE7QUFDQTtBQUNBO0FBcFJBO0FBQ0E7QUFnUkE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFKQTtBQVNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);